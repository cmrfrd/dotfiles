#+TITLE: Alex's Emacs Configuration
#+AUTHOR: Alexander J. Comerford
#+OPTIONS: toc:nil num:nil

#       _.--._  _.--._
# ,-=.-":;:;:;\':;:;:;"-._
# \\\:;:;:;:;:;\:;:a:;:;:;\
#  \\\:;:;:;m;:;\:;:;:c:;:;\
#   \\\:;e;:;:;:;\:;:;:;:s:;\
#    \\\:;:;:;:;:;\:;::;:;:;:\
#     \\\;:;::;:;:;\:;:;:;::;:\
#      \\\;;:;:_:--:\:_:--:_;:;\
#       \\\_.-"      :      "-._\
#        \`_..--""--.;.--""--.._=>
#

This goal of this file `mainconfig.org` is to centralize
most of my development environment configuration to a single
easily searchable, modifyable, and portable format/place
so no matter what system I end up moving too I can have
a full (or atleast partial) development environment that can
provide me some nice garuntees

* TODO Garuntees
...

* Configure =use-package=

The primary goal with this configuration file
is that on loading emacs for the first time, my
personal development environment will be fully
setup and ready for me to use.

#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+END_SRC

#+RESULTS:
: t

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))

  (setq load-prefer-newer t)
#+END_SRC

#+RESULTS:
: t

* Use sensible-defaults.el

[[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] is a fantastic setup script allowing users
to get started with nice emacs defaults that gets them started
quickly.

In this section I have selected the best samples of what is
available.

#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/resources/sensible-defaults.el")
  (sensible-defaults/backup-to-temp-directory)
  (sensible-defaults/bind-keys-to-change-text-size)
  (sensible-defaults/bind-commenting-and-uncommenting)
  (sensible-defaults/increase-gc-threshold)
  (sensible-defaults/delete-trailing-whitespace)
  (sensible-defaults/automatically-follow-symlinks)
  (sensible-defaults/overwrite-selected-text)
  (sensible-defaults/ensure-that-files-end-with-newline)
  (sensible-defaults/quiet-startup)
  (sensible-defaults/make-dired-file-sizes-human-readable)
  (sensible-defaults/shorten-yes-or-no)
  (sensible-defaults/always-highlight-code)
  (sensible-defaults/refresh-buffers-when-files-change)
  (sensible-defaults/show-matching-parens)
  (sensible-defaults/flash-screen-instead-of-ringing-bell)
  (sensible-defaults/set-default-line-length-to 80)
  (sensible-defaults/yank-to-point-on-mouse-click)
#+END_SRC

#+RESULTS:
: t

* Personal information
** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Alexander J. Comerford"
        user-mail-address "alexanderjcomerford@gmail.com"
        calendar-latitude 40.6501
        calendar-longitude -73.94958
        calendar-location-name "New York, NY")
#+END_SRC

#+RESULTS:
: Boulder, CO

* Add =resources= to =load-path=

Just write elisp to resources to have it auto eval'd

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+END_SRC

* =evil-mode=

I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
usually not what I want. In particular, it makes working with Coq really
frustrating.

#+BEGIN_SRC emacs-lisp
  (setq evil-want-abbrev-expand-on-insert-exit nil)
#+END_SRC

Use =evil=.

#+BEGIN_SRC emacs-lisp
(use-package evil
    :config
    (evil-mode 1)
(setq evil-default-state 'emacs))
#+END_SRC

Enable =surround= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+END_SRC

Use =evil= with Org agendas.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda () (evil-org-set-key-theme)))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+END_SRC
* Utility functions

Define a big ol' bunch of handy utility functions.

#+BEGIN_SRC emacs-lisp
  (defun ajc/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
               (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun ajc/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun ajc/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun ajc/visit-last-migration ()
    "Open the most recent Rails migration. Relies on projectile."
    (interactive)
    (let ((migrations
           (directory-files
            (expand-file-name "db/migrate" (projectile-project-root)) t)))
      (find-file (car (last migrations)))))

  (defun ajc/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun ajc/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun ajc/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun ajc/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+END_SRC

* UI

La bella figura! Make it beautiful!

** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
  (global-linum-mode t)
#+END_SRC

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

#+BEGIN_SRC emacs-lisp
  (set-window-scroll-bars (minibuffer-window) nil nil)
#+END_SRC

The default frame title isn't useful. This binds it to the name of the current
project:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Load up a theme

I pretty much don't care about wallpapers or transparency but i'll enable a bit of it.

Themes are a nice switch of pace from the numdane black and white

#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    :config
    (load-theme 'tsdh-dark t)

    (setq solarized-use-variable-pitch nil
          solarized-height-plus-1 1.0
          solarized-height-plus-2 1.0
          solarized-height-plus-3 1.0
          solarized-height-plus-4 1.0)

    (let ((line (face-attribute 'mode-line :underline)))
      (set-face-attribute 'mode-line          nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :underline  line)
      (set-face-attribute 'mode-line          nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))

  (use-package kaolin-themes
    :ensure t)

  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))

  (defun ajc/apply-theme ()
    "Apply the `tsdh-dark' theme and make frames just slightly transparent."
    (interactive)
    (load-theme 'tsdh-dark t)
    (transparency 10))
#+END_SRC

#+RESULTS:
: ajc/apply-theme

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+BEGIN_SRC emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame (ajc/apply-theme))))
    (ajc/apply-theme))
#+END_SRC

** Use =moody= for a beautiful modeline

This gives me a truly lovely ribbon-based modeline.

#+BEGIN_SRC emacs-lisp
  (use-package moody
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+END_SRC

#+RESULTS:
: t

** Use =minions= to hide all minor modes

I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

#+BEGIN_SRC emacs-lisp
   (use-package minions
     :config
     (setq minions-mode-line-lighter ""
           minions-mode-line-delimiters '("" . ""))
     (minions-mode 1))
#+END_SRC

** Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Set default font and configure font resizing

I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+BEGIN_SRC emacs-lisp
  (setq ajc/default-font "Inconsolata")
  (setq ajc/default-font-size 8)
  (setq ajc/current-font-size ajc/default-font-size)

  (setq ajc/font-change-increment 1.1)

  (defun ajc/font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat ajc/default-font "-" (number-to-string ajc/current-font-size)))

  (defun ajc/set-font-size ()
    "Set the font to `ajc/default-font' at `ajc/current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (ajc/font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))

  (defun ajc/reset-font-size ()
    "Change font size back to `ajc/default-font-size'."
    (interactive)
    (setq ajc/current-font-size ajc/default-font-size)
    (ajc/set-font-size))

  (defun ajc/increase-font-size ()
    "Increase current font size by a factor of `ajc/font-change-increment'."
    (interactive)
    (setq ajc/current-font-size
          (ceiling (* ajc/current-font-size ajc/font-change-increment)))
    (ajc/set-font-size))

  (defun ajc/decrease-font-size ()
    "Decrease current font size by a factor of `ajc/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq ajc/current-font-size
          (max 1
               (floor (/ ajc/current-font-size ajc/font-change-increment))))
    (ajc/set-font-size))

  (define-key global-map (kbd "C-)") 'ajc/reset-font-size)
  (define-key global-map (kbd "C-+") 'ajc/increase-font-size)
  (define-key global-map (kbd "C-=") 'ajc/increase-font-size)
  (define-key global-map (kbd "C-_") 'ajc/decrease-font-size)
  (define-key global-map (kbd "C--") 'ajc/decrease-font-size)

  (ajc/reset-font-size)
#+END_SRC

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
#+END_SRC

Make hotkey to turn this on and off. This can be useful
if I'm showing a presentation and want to show the audience
where to look

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-h C-l")  'global-hl-line-mode)
#+END_SRC

#+RESULTS:
: global-hl-line-mode

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :config
    (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
    (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+END_SRC

* Project management

Here are a few emacs packages that are extremely useful including
manage the project, handle auto-completion, search for terms, and
deal with version control.

** =ag=

Set up =ag= for displaying search results.

#+BEGIN_SRC emacs-lisp
  (use-package ag)
#+END_SRC

** =company=

Use =company-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package company)
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

Use =M-/= for completion.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+END_SRC

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. I've bound its most useful command to
=M-.=.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :config
    ;(define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+END_SRC

#+RESULTS:
: t

** =flycheck=

#+BEGIN_SRC emacs-lisp
   (use-package flycheck)
#+END_SRC

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
  push=, which automatically creates a tracking branch on (usually) =origin=.
  Magit, by default, wants me to manually specify an upstream branch. This binds
  =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
  -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
    (use-package evil-magit)
    (use-package with-editor)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)

    (with-eval-after-load 'magit-remote
      (magit-define-popup-action 'magit-push-popup ?P
        'magit-push-implicitly--desc
        'magit-push-implicitly ?p t))

    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+BEGIN_SRC emacs-lisp
  (use-package ghub)
  ;(use-package forge)
#+END_SRC

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . 'projectile-ag)

    :config
    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

    (projectile-mode +1)

    (setq projectile-completion-system 'ivy)
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-require-project-root nil))
#+END_SRC

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree)
#+END_SRC

** =tramp=

TRAMP (Transparent Remote Access, Multiple Protocols) is a package for editing
remote files, similar to AngeFtp or efs.

It's extremely handy when dealing with containers or vms and not having to rebuild
a bunch of things just to see a simple change.

#+BEGIN_SRC emacs-lisp
;; use docker tramp names
(use-package docker-tramp
  :ensure docker-tramp
  :config
  (setq docker-tramp-use-names t))

;; vagrant vms too
(use-package vagrant-tramp
  :ensure t)

(require 'docker-tramp-compat)
(use-package tramp
  :ensure t
  :defer t
  :config
  (setf tramp-persistency-file-name
        (concat temporary-file-directory "tramp-" (user-login-name))))
#+END_SRC

** =neotree=

This is a similar functionality of spacemacs with a foldable structure.

Pretty handy when dealing with a large code base

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :init
  (progn
    ;; Every time when the neotree window is opened, it will try to find current
    ;; file and jump to node.
    (setq-default neo-smart-open t)
    (setq-default neo-dont-be-alone t)
    (setq-default neo-window-fixed-size nil)
    (setq-default neo-show-hidden-files t))
  :config
  (progn
    (setq projectile-switch-project-action 'neotree-projectile-action)
    (setq neo-theme 'nerd) ; 'classic, 'nerd, 'ascii, 'arrow
    (setq neo-vc-integration '(face char))

    ;; Patch to fix vc integration
    (defun neo-vc-for-node (node)
      (let* ((backend (vc-backend node))
             (vc-state (when backend (vc-state node backend))))
        ;; (message "%s %s %s" node backend vc-state)
        (cons (cdr (assoc vc-state neo-vc-state-char-alist))
              (cl-case vc-state
                (up-to-date       neo-vc-up-to-date-face)
                (edited           neo-vc-edited-face)
                (needs-update     neo-vc-needs-update-face)
                (needs-merge      neo-vc-needs-merge-face)
                (unlocked-changes neo-vc-unlocked-changes-face)
                (added            neo-vc-added-face)
                (removed          neo-vc-removed-face)
                (conflict         neo-vc-conflict-face)
                (missing          neo-vc-missing-face)
                (ignored          neo-vc-ignored-face)
                (unregistered     neo-vc-unregistered-face)
                (user             neo-vc-user-face)
                (t                neo-vc-default-face)))))

    (defun modi/neotree-go-up-dir ()
      (interactive)
      (goto-char (point-min))
      (forward-line 2)
      (neotree-change-root))

    ;; http://emacs.stackexchange.com/a/12156/115
    (defun modi/find-file-next-in-dir (&optional prev)
      "Open the next file in the directory.
When PREV is non-nil, open the previous file in the directory."
      (interactive "P")
      (let ((neo-init-state (neo-global--window-exists-p)))
        (if (null neo-init-state)
            (neotree-show))
        (neo-global--select-window)
        (if (if prev
                (neotree-previous-line)
              (neotree-next-line))
            (progn
              (neo-buffer--execute nil
                                   (quote neo-open-file)
                                   (lambda (full-path &optional arg)
                                     (message "Reached dir: %s/" full-path)
                                     (if prev
                                         (neotree-next-line)
                                       (neotree-previous-line)))))
          (progn
            (if prev
                (message "You are already on the first file in the directory.")
              (message "You are already on the last file in the directory."))))
        (if (null neo-init-state)
            (neotree-hide))))

    (defun modi/find-file-prev-in-dir ()
      "Open the next file in the directory."
      (interactive)
      (modi/find-file-next-in-dir :prev))

    (bind-keys
     :map neotree-mode-map
      ("^" . modi/neotree-go-up-dir)
      ("<C-return>" . neotree-change-root)
      ("C" . neotree-change-root)
      ("c" . neotree-create-node)
      ("+" . neotree-create-node)
      ("d" . neotree-delete-node)
      ("r" . neotree-rename-node)))

  (add-to-list 'window-size-change-functions
               (lambda (frame)
                 (let ((neo-window (neo-global--get-window)))
                   (unless (null neo-window)
                     (setq neo-window-width (window-width neo-window))))))
  (global-set-key [f8] 'neotree-toggle))
#+END_SRC

* Programming environments

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+END_SRC

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
#+END_SRC

** CSS, Sass, and Less

Indent by 2 spaces.

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :config
    (setq css-indent-offset 2))
#+END_SRC

Don't compile the current SCSS file every time I save.

#+BEGIN_SRC emacs-lisp
  (use-package scss-mode
    :config
    (setq scss-compile-at-save nil))
#+END_SRC

Install Less.

#+BEGIN_SRC emacs-lisp
  (use-package less-css-mode)
#+END_SRC

** Golang

Install =go-mode= and related packages:

#+BEGIN_SRC emacs-lisp
  (use-package go-mode)
  (use-package go-errcheck)
  (use-package company-go)
#+END_SRC

Define my =$GOPATH= and tell Emacs where to find the Go binaries.

#+BEGIN_SRC emacs-lisp
  (setenv "GOPATH" "/home/ajc/code/go")
  (ajc/append-to-path (concat (getenv "GOPATH") "/bin"))
#+END_SRC

Run =goimports= on every file when saving, which formats the file and
automatically updates the list of imports. This requires that the =goimports=
binary be installed.

#+BEGIN_SRC emacs-lisp
  (setq gofmt-command "goimports")
  (add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

When I open a Go file,

- Start up =company-mode= with the Go backend. This requires that the =gocode=
  binary is installed,
- Redefine the default =compile= command to something Go-specific, and
- Enable =flycheck=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'go-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   '(company-go))
              (company-mode)
              (if (not (string-match "go" compile-command))
                  (set (make-local-variable 'compile-command)
                       "go build -v && go test -v && go vet"))
              (flycheck-mode)))
#+END_SRC

** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode)
#+END_SRC

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+BEGIN_SRC emacs-lisp
  (add-hook 'haskell-mode-hook
            (lambda ()
              (haskell-doc-mode)
              (turn-on-haskell-indent)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (ajc/append-to-path "~/.cabal/bin")
#+END_SRC

** JavaScript and CoffeeScript

Install =coffee-mode= from editing CoffeeScript code.

#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode)
#+END_SRC

Indent everything by 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (add-hook 'coffee-mode-hook
            (lambda ()
              (yas-minor-mode 1)
              (setq coffee-tab-width 2)))
#+END_SRC

** Lisps

I like to use =paredit= in Lisp modes to balance parentheses (and more!).

# #+BEGIN_SRC emacs-lisp
#   (use-package paredit)
# #+END_SRC

=rainbow-delimiters= is convenient for coloring matching parentheses.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters)
#+END_SRC

All the lisps have some shared features, so we want to do the same things for
all of them. That includes using =paredit=, =rainbow-delimiters=, and
highlighting the whole expression when point is on a parenthesis.

#+BEGIN_SRC emacs-lisp
  (setq lispy-mode-hooks
        '(clojure-mode-hook
          emacs-lisp-mode-hook
          lisp-mode-hook
          scheme-mode-hook))

  (dolist (hook lispy-mode-hooks)
    (add-hook hook (lambda ()
                     (setq show-paren-style 'expression)
                     (paredit-mode)
                     (rainbow-delimiters-mode))))
#+END_SRC

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :config
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
#+END_SRC

I also like using =flycheck-package= to ensure that my Elisp packages are
correctly formatted.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-package)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package python-mode)
#+END_SRC

Add =~/.local/bin= to load path. That's where =virtualenv= is installed, and
we'll need that for =jedi=.

#+BEGIN_SRC emacs-lisp
  (ajc/append-to-path "~/.local/bin")
#+END_SRC

Enable =elpy=. This provides automatic indentation, auto-completion, syntax
checking, etc.

#+BEGIN_SRC emacs-lisp
  (use-package elpy)
  (elpy-enable)
#+END_SRC

Use =flycheck= for syntax checking:

#+BEGIN_SRC emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC

Format code according to PEP8 on save:

#+BEGIN_SRC emacs-lisp
  (use-package py-autopep8)
  (require 'py-autopep8)
  (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
#+END_SRC

Configure Jedi along with the associated =company= mode:

#+BEGIN_SRC emacs-lisp
  (use-package company-jedi)
  (add-to-list 'company-backends 'company-jedi)

  (add-hook 'python-mode-hook 'jedi:setup)
  (setq jedi:complete-on-dot t)
#+END_SRC

Add anaconda mode

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :ensure anaconda-mode)
(use-package company-anaconda
  :ensure company-anaconda)
#+END_SRC

** =sh=

Indent with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

** Scala

Ensure that =scala-mode= and =sbt-mode= are installed.

#+BEGIN_SRC emacs-lisp
  (use-package scala-mode
    :interpreter
    ("scala" . scala-mode))
  (use-package sbt-mode)
#+END_SRC

Don't show the startup message with launching ENSIME:

#+BEGIN_SRC emacs-lisp
  (setq ensime-startup-notification nil)
#+END_SRC

Bind a few keys to common operations:

#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal ensime-mode-map (kbd "C-t") 'ensime-type-at-point)
  (evil-define-key 'normal ensime-mode-map (kbd "M-.") 'ensime-edit-definition)
#+END_SRC

** =web-mode=

#+BEGIN_SRC emacs-lisp
  (use-package web-mode)
#+END_SRC

If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook
            (lambda ()
              (rainbow-mode)
              (rspec-mode)
              (setq web-mode-markup-indent-offset 2)))
#+END_SRC

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+BEGIN_SRC emacs-lisp
  (ajc/add-auto-mode
   'web-mode
   "\\.erb$"
   "\\.html$"
   "\\.php$"
   "\\.rhtml$")
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode)
#+END_SRC

If I'm editing YAML I'm usually in a Rails project. I'd like to be able to run
the tests from any buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'yaml-mode-hook 'rspec-mode)
#+END_SRC

** Docker

I work with docker containers alot so it's handy to have highlighting available

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure dockerfile-mode)
(require 'dockerfile-mode)
(add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
(use-package docker-compose-mode
  :ensure t)
(use-package docker
  :ensure t
  :bind ("C-c d" . docker))
#+END_SRC
** Markdown

Markdown is a really cool and handy format which most github repos
have. It would be nice to make them easily viewable

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "markdown"))
#+END_SRC
* Terminal

For a while I used =shell-pop= for shell sessions but I'm now transitioning
to using =multi-term= to manage my shell sessions. It's bound to =C-c t=.

#+BEGIN_SRC emacs-lisp
  (use-package multi-term)
  (global-set-key (kbd "C-c t") 'multi-term)
  (setq multi-term-dedicated-select-after-open-p t)
#+END_SRC

#+RESULTS:
: multi-term

Use a login shell:

#+BEGIN_SRC emacs-lisp
  (setq multi-term-program-switches "--login")
#+END_SRC

#+RESULTS:
: --login

I'd rather not use Evil in the terminal. It's not especially useful (I don't use
vi bindings in xterm) and it shadows useful keybindings (=C-d= for EOF, for
example).

#+BEGIN_SRC emacs-lisp
  (evil-set-initial-state 'term-mode 'emacs)
#+END_SRC

I add a bunch of hooks to =term-mode=:

- I'd like links (URLs, etc) to be clickable.
- Yanking in =term-mode= doesn't quite work. The text from the paste appears in
  the buffer but isn't sent to the shell process. This correctly binds =C-y= and
  middle-click to yank the way we'd expect.
- I bind =M-o= to quickly change windows. I'd like that in terminals, too.
- I don't want to perform =yasnippet= expansion when tab-completing.

#+BEGIN_SRC emacs-lisp
  (defun ajc/term-paste (&optional string)
    (interactive)
    (process-send-string
     (get-buffer-process (current-buffer))
     (if string string (current-kill 0))))

  (add-hook 'term-mode-hook
            (lambda ()
              (goto-address-mode)
              (define-key term-raw-map (kbd "C-y") 'ajc/term-paste)
              (define-key term-raw-map (kbd "<mouse-2>") 'ajc/term-paste)
              (define-key term-raw-map (kbd "M-o") 'other-window)
              (define-key term-raw-map (kbd "M-n") 'multi-term-next)
              (define-key term-raw-map (kbd "M-p") 'multi-term-prev)
              (defun term-send-Cr () (interactive) (term-send-raw-string "\C-r"))
              ;(evil-local-set-key 'insert (kbd "C-r") 'term-send-Cr)
              (define-key term-raw-map (kbd "C-r")      'term-send-Cr)
              (defun term-send-Cright () (interactive) (term-send-raw-string "\e[1;5C"))
              (defun term-send-Cleft  () (interactive) (term-send-raw-string "\e[1;5D"))
              (define-key term-raw-map (kbd "C-<right>")      'term-send-Cright)
              (define-key term-raw-map (kbd "C-<left>")       'term-send-Cleft)

              (setq yas-dont-activate t)))
#+END_SRC

#+RESULTS:
| (lambda nil (goto-address-mode) (define-key term-raw-map (kbd C-y) (quote ajc/term-paste)) (define-key term-raw-map (kbd <mouse-2>) (quote ajc/term-paste)) (define-key term-raw-map (kbd M-o) (quote other-window)) (define-key term-raw-map (kbd M-n) (quote multi-term-next)) (define-key term-raw-map (kbd M-p) (quote multi-term-prev)) (defun term-send-Cright nil (interactive) (term-send-raw-string [1;5C)) (defun term-send-Cleft nil (interactive) (term-send-raw-string [1;5D)) (define-key term-raw-map (kbd C-<right>) (quote term-send-Cright)) (define-key term-raw-map (kbd C-<left>) (quote term-send-Cleft)) (setq yas-dont-activate t)) | multi-term-keystroke-setup | (lambda nil (goto-address-mode) (define-key term-raw-map (kbd C-y) (quote ajc/term-paste)) (define-key term-raw-map (kbd <mouse-2>) (quote ajc/term-paste)) (define-key term-raw-map (kbd M-o) (quote other-window)) (define-key term-raw-map (kbd M-n) (quote multi-term-next)) (define-key term-raw-map (kbd M-p) (quote multi-term-prev)) (defun term-send-Cr nil (interactive) (term-send-raw-string )) (evil-local-set-key (quote insert) (kbd C-r) (quote term-send-Cr)) (define-key term-raw-map (kbd C-r) (quote term-send-Cr)) (defun term-send-Cright nil (interactive) (term-send-raw-string [1;5C)) (defun term-send-Cleft nil (interactive) (term-send-raw-string [1;5D)) (define-key term-raw-map (kbd C-<right>) (quote term-send-Cright)) (define-key term-raw-map (kbd C-<left>) (quote term-send-Cleft)) (setq yas-dont-activate t)) | (lambda nil (goto-address-mode) (define-key term-raw-map (kbd C-y) (quote ajc/term-paste)) (define-key term-raw-map (kbd <mouse-2>) (quote ajc/term-paste)) (define-key term-raw-map (kbd M-o) (quote other-window)) (define-key term-raw-map (kbd M-n) (quote multi-term-next)) (define-key term-raw-map (kbd M-p) (quote multi-term-prev)) (defun term-send-Cr nil (interactive) (term-send-raw-string )) (define-key term-raw-map (kbd C-r) (quote term-send-Cr)) (defun term-send-Cright nil (interactive) (term-send-raw-string [1;5C)) (defun term-send-Cleft nil (interactive) (term-send-raw-string [1;5D)) (define-key term-raw-map (kbd C-<right>) (quote term-send-Cright)) (define-key term-raw-map (kbd C-<left>) (quote term-send-Cleft)) (setq yas-dont-activate t)) | (lambda nil (goto-address-mode) (define-key term-raw-map (kbd C-y) (quote ajc/term-paste)) (define-key term-raw-map (kbd <mouse-2>) (quote ajc/term-paste)) (define-key term-raw-map (kbd M-o) (quote other-window)) (define-key term-raw-map (kbd M-n) (quote multi-term-next)) (define-key term-raw-map (kbd M-p) (quote multi-term-prev)) (define-key term-raw-map (kbd C-r) (quote multi-term-prev)) (defun term-send-Cright nil (interactive) (term-send-raw-string [1;5C)) (defun term-send-Cleft nil (interactive) (term-send-raw-string [1;5D)) (define-key term-raw-map (kbd C-<right>) (quote term-send-Cright)) (define-key term-raw-map (kbd C-<left>) (quote term-send-Cleft)) (setq yas-dont-activate t)) | (lambda nil (goto-address-mode) (define-key term-raw-map (kbd C-y) (quote ajc/term-paste)) (define-key term-raw-map (kbd <mouse-2>) (quote ajc/term-paste)) (define-key term-raw-map (kbd M-o) (quote other-window)) (define-key term-raw-map (kbd M-n) (quote multi-term-next)) (define-key term-raw-map (kbd M-p) (quote multi-term-prev)) (setq yas-dont-activate t)) |

I have this really cool function so I can send regions to a terminal. Really
handy when you want to execute selections without copying and pasting

#+BEGIN_SRC emacs-lisp
;;
;; Send region to running emacs process
;;
(global-set-key (kbd "C-u") #'tws-region-to-process)
(defun tws-region-to-process (arg beg end)
  "Send the current region to a process buffer.
The first time it's called, will prompt for the buffer to
send to. Subsequent calls send to the same buffer, unless a
prefix argument is used (C-u), or the buffer no longer has an
active process."
  (interactive "P\nr")
  (when (or arg ;; user asks for selection
          (not (boundp 'tws-process-target)) ;; target not set
          ;; or target is not set to an active process:
          (not (process-live-p (get-buffer-process tws-process-target))))
    (let (procs buf)
     (setq procs (remove nil (seq-map
                  (lambda (el)
                    (when (setq buf (process-buffer el))
                      (buffer-name buf)))
                  (process-list))))
     (if (not procs) (error "No process buffers currently open.")
      (setq tws-process-target (completing-read "Process: " procs)))))
  ;(process-send-region tws-process-target beg end))
  (process-send-string tws-process-target (buffer-substring beg end)))
#+END_SRC

* Publishing and task management with Org-mode

#+BEGIN_SRC emacs-lisp
  (use-package org)
#+END_SRC

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Quickly insert a block of elisp:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+END_SRC

** Task and org-capture management

Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list), and archive finished tasks in
=~/documents/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/Dropbox/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC

I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
append them to an "inbox.org" file in my Dropbox. This function lets me import
them easily from that inbox file to my index.

#+BEGIN_SRC emacs-lisp
  (defun ajc/copy-tasks-from-inbox ()
    (when (file-exists-p org-inbox-file)
      (save-excursion
        (find-file org-index-file)
        (goto-char (point-max))
        (insert-file-contents org-inbox-file)
        (delete-file org-inbox-file))))
#+END_SRC

I store all my todos in =~/documents/org/index.org=, so I'd like to derive my
agenda from there.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (defun ajc/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'ajc/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

**** Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/documents/notes/blog-ideas.org=,
- Maintain a todo list in =~/documents/org/index.org=.
- Convert emails into todos to maintain an empty inbox.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("b" "Blog idea"
           entry
           (file "~/documents/notes/blog-ideas.org")
           "* %?\n")

          ("e" "Email" entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n\n%a\n\n")

          ("f" "Finished book"
           table-line (file "~/documents/notes/books-read.org")
           "| %^{Title} | %^{Author} | %u |")

          ("r" "Reading"
           checkitem
           (file (org-file-path "to-read.org")))

          ("s" "Subscribe to an RSS feed"
           plain
           (file "~/documents/rss/urls")
           "%^{Feed URL} \"~%^{Feed name}\"")

          ("t" "Todo"
           entry
           (file+headline org-index-file "Inbox")
           "* TODO %?\n")))
#+END_SRC

When I'm starting an Org capture template I'd like to begin in insert mode. I'm
opening it up in order to start typing something, so this skips a step.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

Refiling according to the document's hierarchy.

#+BEGIN_SRC emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC

Hit =C-c i= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun ajc/open-index-file ()
    "Open the master org TODO list."
    (interactive)
    (ajc/copy-tasks-from-inbox)
    (find-file org-index-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c i") 'ajc/open-index-file)
#+END_SRC

Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

** Exporting

Allow export to markdown and beamer (for presentations).

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (use-package graphviz-dot-mode)
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
#+END_SRC

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")

  (setenv "BROWSER" "firefox")
#+END_SRC

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC


** TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t)
#+END_SRC

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

Open compiled PDFs in =zathura= instead of in the editor.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
        '(lambda ()
           (delete '("\\.pdf\\'" . default) org-file-apps)
           (add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s"))))
#+END_SRC

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+END_SRC
* =dired=

Hide dotfiles by default, but toggle their visibility with =.=.

#+BEGIN_SRC emacs-lisp
  (use-package dired-hide-dotfiles
    :config
    (dired-hide-dotfiles-mode)
    (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
#+END_SRC

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (use-package dired-open
    :config
    (setq dired-open-extensions
          '(("pdf" . "zathura")
            ("mkv" . "vlc")
            ("mp3" . "vlc")
            ("mp4" . "vlc")
            ("avi" . "vlc"))))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
#+END_SRC

Use "j" and "k" to move around in =dired=.

#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
  (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+END_SRC

Kill buffers of files/directories that are deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

Open a file with an external program (that is, through =xdg-open=) by hitting
=C-c C-o=.

#+BEGIN_SRC emacs-lisp
  (defun dired-xdg-open ()
    "In dired, open the file named on this line."
    (interactive)
    (let* ((file (dired-get-filename nil t)))
      (call-process "xdg-open" nil 0 nil file)))

  (define-key dired-mode-map (kbd "C-c C-o") 'dired-xdg-open)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(use-package ranger
  :ensure ranger)
(ranger-override-dired-mode t)
#+END_SRC

#+RESULTS:
: t

* Editing settings

** Quickly visit Emacs configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+BEGIN_SRC emacs-lisp
  (defun ajc/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c e") 'ajc/visit-emacs-config)
#+END_SRC

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'ajc/kill-current-buffer)
#+END_SRC

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+BEGIN_SRC emacs-lisp
  (use-package helpful)

  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
  (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window)
#+END_SRC

** Look for executables in =/usr/local/bin=

#+BEGIN_SRC emacs-lisp
  (ajc/append-to-path "/usr/local/bin")
#+END_SRC

** Save my location within a file

Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+BEGIN_SRC emacs-lisp
  (save-place-mode t)
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Install and configure =which-key=

=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =projectile=, for example).

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+END_SRC

** Configure =yasnippet=

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet)
#+END_SRC

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+END_SRC

I /don’t/ want =yas= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** Configure =ivy= and =counsel=

I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind
    ("M-X" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package flx)
    (use-package smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+END_SRC

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (defun ajc/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun ajc/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'ajc/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'ajc/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (use-package wgrep)

  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Use projectile everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/ajc/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (use-package engine-mode)
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine youtube
    "https://www.youtube.com/results?search_query=%s")

  (engine-mode t)
#+END_SRC

* Helm

Man the ship! Helm is a sub community of emacs users who build
applications ontop of the Helm framework for standard utilities.

It's extremely handy for autocompleting without tab completion!

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :bind (("M-x" . helm-M-x)
         ("C-x b" . helm-buffers-list)
         ("C-x f" . helm-find-files)
         ("C-x r b" . helm-bookmarks)))
#+END_SRC

#+RESULTS:
: helm-bookmarks

** High level helm setup modes and things

#+BEGIN_SRC emacs-lisp
(require 'helm-config)
(helm-mode 1)

;; Globally enable fuzzy matching for helm-mode.
(setq helm-mode-fuzzy-match t)
(setq helm-completion-in-region-fuzzy-match t)
(setq helm-M-x-fuzzy-match t)
(setq helm-buffers-fuzzy-matching t)
(setq helm-recentf-fuzzy-match t)
(customize-set-variable 'helm-ff-lynx-style-map t)

;; Enter directories with RET, same as ido
;; http://emacs.stackexchange.com/questions/3798/how-do-i-make-pressing-ret-in-helm-find-files-open-the-directory/7896#7896
(defun helm-find-files-navigate-forward (orig-fun &rest args)
  (if (file-directory-p (helm-get-selection))
      (apply orig-fun args)
    (helm-maybe-exit-minibuffer)))
(advice-add 'helm-execute-persistent-action :around #'helm-find-files-navigate-forward)
(with-eval-after-load 'helm-files
  (define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action))

;; Don't show "." and ".." directories when finding files.
;; https://github.com/hatschipuh/better-helm
(with-eval-after-load 'helm-files
  (advice-add 'helm-ff-filter-candidate-one-by-one
              :before-while 'no-dots-display-file-p))
(defvar no-dots-whitelist nil
  "List of helm buffers in which to show dots.")

(defun no-dots-in-white-listed-helm-buffer-p ()
  (member helm-buffer no-dots-whitelist))

(defun no-dots-display-file-p (file)
  ;; in a whitelisted buffer display the file regardless of its name
  (or (no-dots-in-white-listed-helm-buffer-p)
      ;; not in a whitelisted buffer display all files
      ;; which does not end with /. /..
      (not (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file))))

;; major key
(global-set-key [remap execute-extended-command] #'helm-smex)
#+END_SRC

#+RESULTS:
: helm-smex

** Disable helm in some common emacs apps

#+BEGIN_SRC emacs-lisp
;; Disable Helm in the following functions.
;; See: https://github.com/emacs-helm/helm/wiki#customize-helm-mode
(setq helm-completing-read-handlers-alist
      '((find-file-read-only . ido)
        (magit-gitignore . nil)
        (rename-file . ido)))
#+END_SRC

** auxilary helm

This section is mainly for emacs...helm...packages...

#+BEGIN_SRC emacs-lisp
;; Install accompanying helm packages
(use-package helm-projectile
  :ensure t
  :init
  (setq projectile-completion-system 'helm)
  (helm-projectile-on))
(use-package helm-tramp
  :ensure t
  :bind ("C-c s" . helm-tramp)
  :config
   (setq tramp-default-method "docker"))
#+END_SRC

#+RESULTS:
: helm-tramp

* Set custom keybindings

Just a few handy functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-o") 'other-window)
#+END_SRC

Remap when working in terminal Emacs.

#+BEGIN_SRC emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+END_SRC

I like enlarging and shrinking windows easily

#+BEGIN_SRC emacs-lisp
;; hotkey window resizingx
(global-set-key (kbd "C-M-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-M-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-M-<down>") 'shrink-window)
(global-set-key (kbd "C-M-<up>") 'enlarge-window)
#+END_SRC

#+RESULTS:
: enlarge-window

Also switching between windows

#+BEGIN_SRC emacs-lisp
;; window switching hotkeys
(global-set-key (kbd "C-c <left>")  'windmove-left)
(global-set-key (kbd "C-c <right>") 'windmove-right)
(global-set-key (kbd "C-c <up>")    'windmove-up)
(global-set-key (kbd "C-c <down>")  'windmove-down)
#+END_SRC

Nice sliding window scrolling

#+BEGIN_SRC emacs-lisp
;; hotkey scrolling
(defun next-line-and-recenter () (interactive) (next-line) (recenter))
(defun previous-line-and-recenter () (interactive) (previous-line) (recenter))
(global-set-key (kbd "C-n") 'next-line-and-recenter)
(global-set-key (kbd "C-p") 'previous-line-and-recenter)
#+END_SRC

* Extra

I don't know where to put this... it's really handy when re-arranging
buffers for any what reason

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t)
#+END_SRC

Great for jupyter notebook things

#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t)
#+END_SRC
