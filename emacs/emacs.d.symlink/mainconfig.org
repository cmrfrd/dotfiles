#+TITLE: Alex's Emacs Configuration
#+AUTHOR: Alexander J. Comerford
#+OPTIONS: toc:nil num:nil

#       _.--._  _.--._
# ,-=.-":;:;:;\':;:;:;"-._
# \\\:;:;:;:;:;\:;:a:;:;:;\
#  \\\:;:;:;m;:;\:;:;:c:;:;\
#   \\\:;e;:;:;:;\:;:;:;:s:;\
#    \\\:;:;:;:;:;\:;::;:;:;:\
#     \\\;:;::;:;:;\:;:;:;::;:\
#      \\\;;:;:_:--:\:_:--:_;:;\
#       \\\_.-"      :      "-._\
#        \`_..--""--.;.--""--.._.\
#

This goal of this file `mainconfig.org` is to centralize
most of my development environment configuration to a single
easily searchable, modifyable, and portable format/place
so no matter what system I end up moving too I can have
a full (or atleast partial) development environment that can
provide me some nice garuntees

* Garuntees
  1. One window to rule them all (editor, terminal, browser)
  2. Language agnostic dev environment
  3. Export/Import with ease

* Configure =use-package=

  The primary goal with this configuration file
  is that on loading emacs for the first time, my
  personal development environment will be fully
  setup and ready for use.

  To do this we will be using use-package which is
  a lovely declaritive package itself to define how
  to install/configure more packages.

  #+BEGIN_SRC emacs-lisp
    (require 'use-package-ensure)
    (setq use-package-always-ensure t)
    (setq comp-async-report-warnings-errors nil)
    (setq byte-compile-warnings '(cl-functions))
  #+END_SRC

  #+RESULTS:
  | cl-functions |

  Always compile packages, and use the newest version available.

  #+BEGIN_SRC emacs-lisp
    (use-package auto-compile
      :config (auto-compile-on-load-mode))

    (setq load-prefer-newer t)
  #+END_SRC

  #+RESULTS:
  : t

* Setup =straight= package manager

  #+begin_src emacs-lisp
    (setq straight-repository-branch "develop")
    (setq package-enable-at-startup nil)
    (defvar bootstrap-version)
    (let ((bootstrap-file
           (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
          (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))
  #+end_src

  #+RESULTS:
  : t

  #+begin_src emacs-lisp
    (straight-use-package 'enwc)
    (setq enwc-default-backend 'nm)
  #+end_src

  #+RESULTS:
  : nm

  #+begin_src emacs-lisp
    (defun nm-connect-to-wifi-network ()
      (interactive)
      (shell-command
       (concat "nmcli device wifi connect "
               (completing-read "Select network: "
                                (progn
                                  (setq enwc-scan-interactive t)
                                  (map 'list
                                       (lambda (net) (enwc-value-from-scan 'essid net))
                                       (enwc-get-networks))))
               " password "
               (read-passwd "Enter password: "))))
  #+end_src

  #+RESULTS:
  : nm-connect-to-wifi-network

* Use sensible-defaults.el and load custom scripts

  [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] is a fantastic setup script allowing users
  to get started with nice emacs defaults that gets them started
  quickly.

  In this section I have selected the best samples of what is
  available.

  #+BEGIN_SRC emacs-lisp
    (load-file "~/.emacs.d/resources/sensible-defaults.el")
    (sensible-defaults/backup-to-temp-directory)
    (sensible-defaults/bind-keys-to-change-text-size)
    (sensible-defaults/bind-commenting-and-uncommenting)
    (sensible-defaults/increase-gc-threshold)
    (sensible-defaults/delete-trailing-whitespace)
    (sensible-defaults/automatically-follow-symlinks)
    (sensible-defaults/overwrite-selected-text)
    (sensible-defaults/ensure-that-files-end-with-newline)
    (sensible-defaults/quiet-startup)
    (sensible-defaults/make-dired-file-sizes-human-readable)
    (sensible-defaults/shorten-yes-or-no)
    (sensible-defaults/always-highlight-code)
    (sensible-defaults/refresh-buffers-when-files-change)
    (sensible-defaults/show-matching-parens)
    (sensible-defaults/flash-screen-instead-of-ringing-bell)
    (sensible-defaults/set-default-line-length-to 80)
    (sensible-defaults/yank-to-point-on-mouse-click)
    (sensible-defaults/hide-compile-buffer)
  #+END_SRC

  #+RESULTS:
  | lambda | (buf strg) | (let ((win (get-buffer-window buf 'visible))) (if win (progn (delete-window win)))) |

  Just write elisp to resources to have it auto eval'd

  Dependencies for resources

  #+BEGIN_SRC emacs-lisp
    (use-package f
      :straight (f :type git :host github :repo "rejeep/f.el" :branch "master"))
    (use-package dash
      :ensure t)
    (use-package request
      :ensure t)
  #+END_SRC

  #+RESULTS:

  #+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/resources/")
    (mapc 'load (file-expand-wildcards "~/.emacs.d/resources/*.el"))
  #+END_SRC

  #+RESULTS:
  | ~/.emacs.d/resources/bitwarden.el | ~/.emacs.d/resources/brightness.el | ~/.emacs.d/resources/crontab.el | ~/.emacs.d/resources/eslint.el | ~/.emacs.d/resources/kv.el | ~/.emacs.d/resources/org-inline-image.el | ~/.emacs.d/resources/org-protocol-capture-html.el | ~/.emacs.d/resources/org-utils.el | ~/.emacs.d/resources/ox-jekyll-lite.el | ~/.emacs.d/resources/pocket-lib.el | ~/.emacs.d/resources/sensible-defaults.el |


  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Alexander Comerford"
          user-mail-address "alex@taoa.io"
          user-alternate-mail-address "alexanderjcomerford@gmail.com"
          calendar-latitude 40.6501
          calendar-longitude -73.94958
          calendar-location-name "New York, NY")
  #+END_SRC

  #+RESULTS:
  : New York, NY


  Evil mode is frustrating at first but allows the
  emacs programmer to be much more fluid in development
  taking the best of these two disparate worlds.

  Use =evil=.

  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :config
      (evil-mode 1)
      (setq evil-default-state 'emacs))
  #+END_SRC

  #+RESULTS:
	: t

  #+BEGIN_SRC emacs-lisp
    (setq evil-want-abbrev-expand-on-insert-exit nil)
    (setq evil-toggle-key "C-q C-z")
  #+END_SRC

  #+RESULTS:
	: C-q C-z

  Enable =surround= everywhere.

  #+BEGIN_SRC emacs-lisp
    (use-package evil-surround
      :config
      (global-evil-surround-mode 1))
  #+END_SRC

  #+RESULTS:
	: t

  Use =evil= with Org agendas.

  #+BEGIN_SRC emacs-lisp
    (use-package evil-org
      :after org
      :config
      (add-hook 'org-mode-hook 'evil-org-mode)
      (add-hook 'evil-org-mode-hook
                (lambda () (evil-org-set-key-theme)))
      ;; (require 'evil-org-agenda)
      ;; (evil-org-agenda-set-keys)
      )
  #+END_SRC

  #+RESULTS:
	: t

** Keychain

   #+begin_src emacs-lisp
     (use-package keychain-environment
       :straight (keychain-environment :type git :host github :repo "tarsius/keychain-environment" :branch "master"))
     (keychain-refresh-environment)
   #+end_src

   #+RESULTS:
   | /tmp/ssh-XXXXXXTYIVpu/agent.2596 | 2598 | nil |

* Utility functions
** Big ol' bunch of handy utility functions.

   #+BEGIN_SRC emacs-lisp

     (defun ajc/add-auto-mode (mode &rest patterns)
       "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
       (dolist (pattern patterns)
         (add-to-list 'auto-mode-alist (cons pattern mode))))

     (defun ajc/find-file-as-sudo ()
       (interactive)
       (let ((file-name (buffer-file-name)))
         (when file-name
           (find-alternate-file (concat "/sudo::" file-name)))))

     (defun ajc/region-or-word ()
       (if mark-active
           (buffer-substring-no-properties (region-beginning)
                                           (region-end))
         (thing-at-point 'word)))

     (defun ajc/append-to-path (path)
       "Add a path both to the $PATH variable and to Emacs' exec-path."
       (setenv "PATH" (concat (getenv "PATH") ":" path))
       (add-to-list 'exec-path path))

     (defun assoc-recursive (alist &rest keys)
       "Recursively find KEYs in ALIST."
       (while keys
         (setq alist (cdr (assoc (pop keys) alist))))
       alist)
   #+END_SRC

   #+RESULTS:
	 : assoc-recursive

   #+BEGIN_SRC emacs-lisp
     (defvar auto-answer 'ask
       "When bound, yes-or-no questions will not prompt.
        When this variable is bound to a boolean value, the functions
        `yes-or-no-p' and `y-or-n-p' will return that value without
        prompting.  With its default value (the symbol `ask'), the
        functions will prompt normally.")

     (defun auto-answer (oldfun &rest args)
       (if (booleanp auto-answer)
           auto-answer
         (apply oldfun args)))

     (advice-add 'y-or-n-p :around 'auto-answer)
     (advice-add 'yes-or-no-p :around 'auto-answer)
   #+END_SRC

   #+RESULTS:

** File manipulation

   Here are some cool file / buffer manipulation functions that I use

   #+begin_src emacs-lisp
     (defun ajc/rename-file (new-name)
       (interactive "New name: ")
       (let ((filename (buffer-file-name)))
         (if filename
             (progn
               (when (buffer-modified-p)
                 (save-buffer))
               (rename-file filename new-name t)
               (kill-buffer (current-buffer))
               (find-file new-name)
               (message "Renamed '%s' -> '%s'" filename new-name))
           (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

     (defun ajc/tmpdir ()
       (interactive)
       (let ((path
              (f-join temporary-file-directory (make-temp-name ""))))
         (make-directory path)
         path))

     (defmacro safe-wrap (fn &rest clean-up)
       `(unwind-protect
            (let (retval)
              (condition-case ex
                  (setq retval (progn ,fn))
                ('error
                 (setq retval (cons 'exception (list ex)))))
              retval)
          ,@clean-up))

     (defun ajc/generate-scratch-buffer ()
       "Create and switch to a temporary scratch buffer with a random
            name."
       (interactive)
       (switch-to-buffer (make-temp-name "scratch-")))

     (defun ajc/generate-scratch-file ()
       "Create and switch to a temporary scratch file with a random
            name."
       (interactive)
       (switch-to-buffer (find-file (make-temp-file "scratch-"))))

     (defun ajc/kill-current-buffer ()
       "Kill the current buffer without prompting."
       (interactive)
       (kill-buffer (current-buffer)))
   #+end_src

   #+RESULTS:
	 : ajc/kill-current-buffer

   This function is handy for pgp fingerprints

   #+begin_src emacs-lisp
     (defun split-string-every (string chars)
       "Split STRING into substrings of length CHARS characters.

     This returns a list of strings."
       (cond ((string-empty-p string)
              nil)
             ((< (length string)
                 chars)
              (list string))
             (t (cons (substring string 0 chars)
                      (split-string-every (substring string chars)
                                          chars)))))
   #+end_src

   #+RESULTS:
	 : split-string-every


   A useful utility when opening links

   #+begin_src emacs-lisp
     (defun org-force-open-current-window ()
       (interactive)
       (let ((org-link-frame-setup (quote
                                    ((vm . vm-visit-folder)
                                     (vm-imap . vm-visit-imap-folder)
                                     (gnus . gnus)
                                     (file . find-file)
                                     (wl . wl)))
                                   ))
         (org-open-at-point)))
     ;; Depending on universal argument try opening link
     (defun org-open-maybe (&optional arg)
       (interactive "P")
       (if arg
           (org-open-at-point)
         (org-force-open-current-window)
         )
       )
     ;; Redefine file opening without clobbering universal argumnet
     (define-key org-mode-map "\C-c\C-o" 'org-open-maybe)
   #+end_src

   #+RESULTS:
	 : org-open-maybe

** Async emacs

   #+begin_src emacs-lisp
     (use-package ob-async
       :ensure t)
     (use-package aio
       :ensure t)
   #+end_src

   #+RESULTS:

** Bitwarden Secrets

   I use bitwarden to manage any secrets and stuff. Here are some very handy
   utilities.

   #+begin_src emacs-lisp
     (setq bitwarden-user user-alternate-mail-address)

     (defun bitwarden-unlock-sync ()
       (message "Unlocking bitwarden ...") ;; ....
       (if (not (bitwarden-unlocked-p))
           (progn
             (bitwarden-unlock)
             (while (not (bitwarden-unlocked-p))
               (sleep-for 0.5)
               )))
       (bitwarden-unlocked-p))

     (defun bitwarden-get-note-run (search-criteria)
       (bitwarden-unlock-sync)
       (let ((bitwarden-search-result (bitwarden-search search-criteria)))
         (if (not (= 0 (length bitwarden-search-result)))
             (gethash "notes" (elt bitwarden-search-result 0)))))

     (defun bitwarden-get-note (search-criteria)
       (interactive
        (let ((search-criteria (read-string "Search Criteria: ")))
          (bitwarden-get-note-run search-criteria)))
       (bitwarden-get-note-run search-criteria))
   #+end_src

   #+RESULTS:
	 : bitwarden-get-note

** Pocket

   This is where I can conveniently store link from other devices, very handy,
   however i need a way to access all these links and put them into my mind map.

* UI

  La bella figura! Make it beautiful!

** Line and column numbers

   I think it's handy to have a useful modeline with col,row

   #+BEGIN_SRC emacs-lisp
     (line-number-mode 1)
     (column-number-mode 1)
                                             ; (global-visual-line-mode t)
   #+END_SRC

   #+RESULTS:
	 : t

** Tweak window chrome

   I don't usually use the menu or scroll bar, and they take up useful space.

   #+BEGIN_SRC emacs-lisp
     (setq default-directory "~/")
     (tool-bar-mode 0)
     (menu-bar-mode 0)
     (scroll-bar-mode 0)
     (global-linum-mode t)
     (global-auto-revert-mode t)
   #+END_SRC

   #+RESULTS:
	 : t

   There's a tiny scroll bar that appears in the minibuffer window. This disables
   that:

   #+BEGIN_SRC emacs-lisp
     (set-window-scroll-bars (minibuffer-window) nil nil)
   #+END_SRC

   #+RESULTS:
	 : t

   The default frame title isn't useful. This binds it to the name of the current
   project:

   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format nil)
   #+END_SRC

   #+RESULTS:

** Make tabs

   #+BEGIN_SRC emacs-lisp
     (use-package elscreen
       :ensure t
       :init
       (setq elscreen-prefix-key "\C-q")
       (elscreen-start)
       )
     (use-package elscreen-tab
       :ensure t
       :init
       (elscreen-tab-mode)
       (elscreen-tab-set-position 'top)
       )
   #+END_SRC

   #+RESULTS:
	 : t

** Use fancy lambdas

   Why not?

   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode t)
   #+END_SRC

   #+RESULTS:
	 : t

** Load up a theme

   I pretty much don't care about wallpapers or transparency but i'll enable a bit of it.

   Themes are a nice switch of pace from the numdane black and white

   #+BEGIN_SRC emacs-lisp
     (defun transparency (value)
       "Sets the transparency of the frame window. 0=transparent/100=opaque."
       (interactive "nTransparency Value 0 - 100 opaque:")
       (set-frame-parameter (selected-frame) 'alpha value))
   #+END_SRC

   #+RESULTS:
   : ajc/apply-theme

   This modeline looks informative and pretty at the same time!

   #+begin_src emacs-lisp
     (use-package all-the-icons
       :straight (all-the-icons :type git :host github :repo "domtronn/all-the-icons.el" :branch "master"))
   #+end_src

   #+RESULTS:

   #+BEGIN_SRC emacs-lisp
     (use-package doom-modeline
       :straight t
       :ensure t
       :config
       ;; install fonts
       (let ((path
              (concat (or (getenv "XDG_DATA_HOME")
                          (concat (getenv "HOME") "/.local/share"))
                      "/fonts/")))
         (cond ((not (f-exists? path)) (all-the-icons-install-fonts t))))

       (doom-modeline-mode 1)
       (setq doom-modeline-icon (display-graphic-p))
       (setq doom-modeline-buffer-file-name-style 'truncate-all)
       (setq doom-modeline-buffer-state-icon t)
       (setq doom-modeline-percentage-info nil)
                                             ; (setq doom-modeline-indent-info t)
       (setq doom-modeline-major-modees-icon t)
       (setq doom-modeline-major-mode-color-icon t)
       (setq doom-modeline-minor-modes nil)
       (setq doom-modeline-github nil)
       (set-face-attribute 'mode-line nil :height 80)
       (set-face-attribute 'mode-line-inactive nil :height 80))
   #+END_SRC

   #+RESULTS:
   : t

   Also don't forget about doom themes!!!

   #+begin_src emacs-lisp
     (use-package doom-themes
       :straight t
       :ensure t
       :config
       ;; Global settings (defaults)
       (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
             doom-themes-enable-italic t) ; if nil, italics is universally disabled

       ;; Enable flashing mode-line on errors
       (doom-themes-visual-bell-config)

       ;; Enable custom neotree theme (all-the-icons must be installed!)
       ;; (doom-themes-neotree-config)
       ;; or for treemacs users
       (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
       ;; (doom-themes-treemacs-config)

       ;; Corrects (and improves) org-mode's native fontification.
       (doom-themes-org-config)

       (load-theme 'doom-spacegrey t)
       )
   #+end_src

   #+RESULTS:
   : t

** Emojis!

   #+begin_src emacs-lisp
     (use-package emojify
       :ensure t)
   #+end_src

   #+RESULTS:

** Use =minions= to hide all minor modes

   I never want to see a minor mode, and manually adding =:diminish= to every
   use-package declaration is a hassle. This uses =minions= to hide all the minor
   modes in the modeline. Nice!

   By default there's a =;-)= after the major mode; that's an adorable default, but
   I'd rather skip it.

   #+BEGIN_SRC emacs-lisp
     (use-package minions
       :config
       (setq minions-mode-line-lighter ""
             minions-mode-line-delimiters '("" . ""))
       (minions-mode 1))
   #+END_SRC

** Disable visual bell
   #+RESULTS:
	 : t


   =sensible-defaults= replaces the audible bell with a visual one, but I really
   don't even want that (and my Emacs/Mac pair renders it poorly). This disables
   the bell altogether.

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

** Scroll conservatively

   When point goes outside the window, Emacs usually recenters the buffer point.
   I'm not crazy about that. This changes scrolling behavior to only scroll as far
   as point goes.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 100)
   #+END_SRC

** Set default font and configure font resizing

   I'm partial to Inconsolata.

   The standard =text-scale-= functions just resize the text in the current buffer;
   I'd generally like to resize the text in /every/ buffer, and I usually want to
   change the size of the modeline, too (this is especially helpful when
   presenting). These functions and bindings let me resize everything all together!

   Note that this overrides the default font-related keybindings from
   =sensible-defaults=.

   #+BEGIN_SRC emacs-lisp
     (setq ajc/default-font "SourceCodePro")
     (setq ajc/default-font-size 8)
     (setq ajc/current-font-size ajc/default-font-size)

     (setq ajc/font-change-increment 1.1)

     (defun ajc/font-code ()
       "Return a string representing the current font (like \"Inconsolata-14\")."
       (concat ajc/default-font "-" (number-to-string ajc/current-font-size)))

     (defun ajc/set-font-size ()
       "Set the font to `ajc/default-font' at `ajc/current-font-size'.
     Set that for the current frame, and also make it the default for
     other, future frames."
       (let ((font-code (ajc/font-code)))
         (add-to-list 'default-frame-alist (cons 'font font-code))
         (set-frame-font font-code)))

     (defun ajc/reset-font-size ()
       "Change font size back to `ajc/default-font-size'."
       (interactive)
       (setq ajc/current-font-size ajc/default-font-size)
       (ajc/set-font-size))

     (defun ajc/increase-font-size ()
       "Increase current font size by a factor of `ajc/font-change-increment'."
       (interactive)
       (text-scale-increase 1))

     (defun ajc/decrease-font-size ()
       "Decrease current font size by a factor of `ajc/font-change-increment', down to a minimum size of 1."
       (interactive)
       (text-scale-decrease 1))

     (define-key global-map (kbd "C-)") 'ajc/reset-font-size)
     (define-key global-map (kbd "C-+") 'ajc/increase-font-size)
     (define-key global-map (kbd "C-=") 'ajc/increase-font-size)
     (define-key global-map (kbd "C-_") 'ajc/decrease-font-size)
     (define-key global-map (kbd "C--") 'ajc/decrease-font-size)

     (ajc/reset-font-size)
   #+END_SRC

   #+RESULTS:

** Highlight the current line and cursor

   =global-hl-line-mode= softly highlights the background color of the line
   containing point. It makes it a bit easier to find point, and it's useful when
   pairing or presenting code.

   Make hotkey to turn this on and off. This can be useful
   if I'm showing a presentation and want to show the audience
   where to look

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-h C-l")  'global-hl-line-mode)
   #+END_SRC

   #+RESULTS:
	 : global-hl-line-mode

** Highlight uncommitted changes

   Use the =diff-hl= package to highlight changed-and-uncommitted lines when
   programming.

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :config
       (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
       (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
   #+END_SRC

* Project management

  Here are a few emacs packages that are extremely useful including
  manage the project, handle auto-completion, search for terms, and
  deal with version control.

** =ag=

   Set up =ag= for displaying search results.

   #+BEGIN_SRC emacs-lisp
     (use-package ag)
   #+END_SRC

** =company=

   Use =company-mode= everywhere.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :hook (prog-mode . company-mode)
       :custom
       (company-begin-commands '(self-insert-command))
       (company-idle-delay .1)
       (company-minimum-prefix-length 2)
       (company-show-numbers t)
       (company-tooltip-align-annotations 't)
       (global-company-mode t)
       :config
       (setq company-tooltip-align-annotations t)
       (setq company-minimum-prefix-length 1))
     (add-hook 'after-init-hook 'global-company-mode)
   #+END_SRC

   #+RESULTS:
   | global-company-mode | dashboard-refresh-buffer | org-roam-mode | x-wm-set-size-hint | tramp-register-archive-file-name-handler | magit-maybe-define-global-key-bindings | table--make-cell-map |

   Use =M-/= for completion.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-/") 'company-complete-common)
     (global-set-key (kbd "C-<tab>") 'company-complete)
   #+END_SRC

   #+RESULTS:
	 : company-complete

   Add nice completion box

   #+begin_src emacs-lisp :results output silent
     (use-package company-box
       :ensure t
       :hook (company-mode . company-box-mode))
   #+end_src

** =dumb-jump=

   The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
   doesn't require any additional setup. I've bound its most useful command to
   =M-.=.

   #+BEGIN_SRC emacs-lisp
     (use-package dumb-jump
       :config
                                             ;(define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
       (setq dumb-jump-selector 'ivy))
   #+END_SRC

   #+RESULTS:
	 : t

** =flycheck=

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck :ensure t)
   #+END_SRC

** =magit=

   I use =magit= to handle version control. It's lovely, but I tweak a few things:

   - I bring up the status menu with =C-x g=.
   - Use =evil= keybindings with =magit=.
   - The default behavior of =magit= is to ask before pushing. I haven't had any
     problems with accidentally pushing, so I'd rather not confirm that every time.
   - Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
     beyond 50 characters.
   - On the command line I'll generally push a new branch with a plain old =git
     push=, which automatically creates a tracking branch on (usually) =origin=.
     Magit, by default, wants me to manually specify an upstream branch. This binds
     =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
     -v=. Convenient!
   - I'd like to start in the insert state when writing a commit message.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind
       ("C-x g" . magit-status)

       :config
       ;; (use-package evil-magit)
       (use-package with-editor
         :ensure t
         :config
         (setq-default with-editor-emacsclient-executable "emacsclient"))
       (setq magit-push-always-verify nil)
       (setq git-commit-summary-max-length 50)

       (with-eval-after-load 'magit-remote
         (magit-define-popup-action 'magit-push-popup ?P
                                    'magit-push-implicitly--desc
                                    'magit-push-implicitly ?p t))

       (add-hook 'with-editor-mode-hook 'evil-insert-state))
   #+END_SRC

   #+RESULTS:
	 : magit-status

   I've been playing around with the newly-released =forge= for managing GitHub PRs
   and issues. Seems slick so far.

   #+BEGIN_SRC emacs-lisp
     (use-package ghub)
     (use-package gh)
                                             ;(use-package forge)
   #+END_SRC

   #+RESULTS:

** =projectile=

   Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
   that I rarely use it (and forget it when I need it). This binds it to the
   easier-to-type =C-c v= to useful searches.

   Bind =C-p= to fuzzy-finding files in the current project. We also need to
   explicitly set that in a few other modes.

   I use =ivy= as my completion system.

   When I visit a project with =projectile-switch-project=, the default action is
   to search for a file in that project. I'd rather just open up the top-level
   directory of the project in =dired= and find (or create) new files from there.

   I'd like to /always/ be able to recursively fuzzy-search for files, not just
   when I'm in a Projectile-defined project. I use the current directory as a
   project root (if I'm not in a "real" project).

   #+BEGIN_SRC emacs-lisp

     (use-package projectile
       :bind
                                             ;("C-c v" . 'projectile-ag)

       :config
       ;; (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
       ;; (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
       ;; (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

       (projectile-mode +1)
       (projectile-global-mode)

       (setq projectile-completion-system 'helm)

       (setq projectile-completion-system 'helm)
       (setq projectile-switch-project-action 'projectile-dired)
       (setq projectile-indexing-method 'alien)
       (setq projectile-require-project-root nil))
   #+END_SRC

   #+RESULTS:
   : t

** =undo-tree=

   I like tree-based undo management. I only rarely need it, but when I do, oh boy.

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :config
       (global-undo-tree-mode))
   #+END_SRC

   #+RESULTS:
	 : t

** =tramp=

   TRAMP (Transparent Remote Access, Multiple Protocols) is a package for editing
   remote files, similar to AngeFtp or efs.

   It's extremely handy when dealing with containers or vms and not having to rebuild
   a bunch of things just to see a simple change.

   #+BEGIN_SRC emacs-lisp
     (use-package tramp
       :ensure t
       :defer t
       :config
       (setf tramp-persistency-file-name
             (concat temporary-file-directory "tramp-" (user-login-name))))

     ;; use docker tramp names
     (use-package docker-tramp
       :ensure docker-tramp
       :config
       (setq docker-tramp-use-names t))

     ;; vagrant vms too
     (use-package vagrant-tramp
       :ensure t)

     (require 'docker-tramp-compat)
   #+END_SRC

   #+RESULTS:
   : docker-tramp-compat

** =neotree=

   This is a similar functionality of spacemacs with a foldable structure.

   Pretty handy when dealing with a large code base

   #+BEGIN_SRC emacs-lisp
     (use-package neotree
       :ensure t
       :init
       (progn
         ;; Every time when the neotree window is opened, it will try to find current
         ;; file and jump to node.
         (setq-default neo-smart-open t)
         (setq-default neo-dont-be-alone t)
         (setq-default neo-window-fixed-size nil)
         (setq-default neo-show-hidden-files t))
       :config
       (progn
         (setq projectile-switch-project-action 'neotree-projectile-action)
         (setq neo-theme 'icons) ; 'classic, 'nerd, 'ascii, 'arrow
         (setq neo-vc-integration '(face char))

         ;; Patch to fix vc integration
         (defun neo-vc-for-node (node)
           (let* ((backend (vc-backend node))
                  (vc-state (when backend (vc-state node backend))))
             ;; (message "%s %s %s" node backend vc-state)
             (cons (cdr (assoc vc-state neo-vc-state-char-alist))
                   (cl-case vc-state
                     (up-to-date       neo-vc-up-to-date-face)
                     (edited           neo-vc-edited-face)
                     (needs-update     neo-vc-needs-update-face)
                     (needs-merge      neo-vc-needs-merge-face)
                     (unlocked-changes neo-vc-unlocked-changes-face)
                     (added            neo-vc-added-face)
                     (removed          neo-vc-removed-face)
                     (conflict         neo-vc-conflict-face)
                     (missing          neo-vc-missing-face)
                     (ignored          neo-vc-ignored-face)
                     (unregistered     neo-vc-unregistered-face)
                     (user             neo-vc-user-face)
                     (t                neo-vc-default-face)))))

         (defun modi/neotree-go-up-dir ()
           (interactive)
           (goto-char (point-min))
           (forward-line 2)
           (neotree-change-root))

         ;; http://emacs.stackexchange.com/a/12156/115
         (defun modi/find-file-next-in-dir (&optional prev)
           "Open the next file in the directory.
     When PREV is non-nil, open the previous file in the directory."
           (interactive "P")
           (let ((neo-init-state (neo-global--window-exists-p)))
             (if (null neo-init-state)
                 (neotree-show))
             (neo-global--select-window)
             (if (if prev
                     (neotree-previous-line)
                   (neotree-next-line))
                 (progn
                   (neo-buffer--execute nil
                                        (quote neo-open-file)
                                        (lambda (full-path &optional arg)
                                          (message "Reached dir: %s/" full-path)
                                          (if prev
                                              (neotree-next-line)
                                            (neotree-previous-line)))))
               (progn
                 (if prev
                     (message "You are already on the first file in the directory.")
                   (message "You are already on the last file in the directory."))))
             (if (null neo-init-state)
                 (neotree-hide))))

         (defun modi/find-file-prev-in-dir ()
           "Open the next file in the directory."
           (interactive)
           (modi/find-file-next-in-dir :prev))

         (bind-keys
          :map neotree-mode-map
          ("^" . modi/neotree-go-up-dir)
          ("<C-return>" . neotree-change-root)
          ("C" . neotree-change-root)
          ("c" . neotree-create-node)
          ("+" . neotree-create-node)
          ("d" . neotree-delete-node)
          ("r" . neotree-rename-node)))

       (add-to-list 'window-size-change-functions
                    (lambda (frame)
                      (let ((neo-window (neo-global--get-window)))
                        (unless (null neo-window)
                          (setq neo-window-width (window-width neo-window))))))
       (global-set-key [f8] 'neotree-toggle))
   #+END_SRC

   #+RESULTS:
	 : t

* Programming environments

  I like shallow indentation, but tabs are displayed as 8 characters by default.
  This reduces that.

  #+BEGIN_SRC emacs-lisp
    (setq-default tab-width 2)
  #+END_SRC

	#+RESULTS:
	: 2

  Auto closing parenthesis and brackets is really sweet and extra mental offloading

  Treating terms in CamelCase symbols as separate words makes editing a little
  easier for me, so I like to use =subword-mode= everywhere.

  #+BEGIN_SRC emacs-lisp
    (use-package subword
      :config (global-subword-mode 1))
  #+END_SRC

	#+RESULTS:
	: t

  Compilation output goes to the =*compilation*= buffer. I rarely have that window
  selected, so the compilation output disappears past the bottom of the window.
  This automatically scrolls the compilation window so I can always see the
  output.

  #+BEGIN_SRC emacs-lisp
    (setq compilation-scroll-output t)
  #+END_SRC

** CSS, Sass, and Less

   Indent by 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (use-package css-mode
       :config
       (setq css-indent-offset 2))
   #+END_SRC

	 #+RESULTS:
	 : t

   Don't compile the current SCSS file every time I save.

   #+BEGIN_SRC emacs-lisp
     (use-package scss-mode
       :config
       (setq scss-compile-at-save nil))
   #+END_SRC

	 #+RESULTS:
	 : t

   Install Less.

   #+BEGIN_SRC emacs-lisp
     (use-package less-css-mode)
   #+END_SRC

	 #+RESULTS:


   Great for jupyter notebook things

   #+BEGIN_SRC emacs-lisp
     (use-package ein
       :ensure t)
   #+END_SRC

	 #+RESULTS:

**  Golang

   Install =go-mode= and related packages:

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode)
     (use-package go-errcheck)
     (use-package company-go)
   #+END_SRC

	 #+RESULTS:

   Define my =$GOPATH= and tell Emacs where to find the Go binaries.

   #+BEGIN_SRC emacs-lisp :results output silent
     (ajc/append-to-path (concat (getenv "GOPATH") "/bin"))
   #+END_SRC

   Run =goimports= on every file when saving, which formats the file and
   automatically updates the list of imports. This requires that the =goimports=
   binary be installed.

   #+BEGIN_SRC emacs-lisp :results output silent
     (setq gofmt-command "goimports")
     (add-hook 'before-save-hook 'gofmt-before-save)
   #+END_SRC

   When I open a Go file,

   - Start up =company-mode= with the Go backend. This requires that the =gocode=
     binary is installed,
   - Redefine the default =compile= command to something Go-specific, and
   - Enable =flycheck=.

   #+BEGIN_SRC emacs-lisp :results output silent
     (add-hook 'go-mode-hook
               (lambda ()
                 (set (make-local-variable 'company-backends)
                      '(company-go))
                 (company-mode)
                 (if (not (string-match "go" compile-command))
                     (set (make-local-variable 'compile-command)
                          "go build -v && go test -v && go vet"))
                 (flycheck-mode)))
   #+END_SRC

** Haskell

   #+BEGIN_SRC emacs-lisp
     (use-package haskell-mode)
   #+END_SRC

	 #+RESULTS:

   Enable =haskell-doc-mode=, which displays the type signature of a function, and
   use smart indentation.

   #+BEGIN_SRC emacs-lisp :results output silent
     (add-hook 'haskell-mode-hook
               (lambda ()
                 (haskell-doc-mode)
                 (turn-on-haskell-indent)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (ajc/append-to-path "~/.cabal/bin")
   #+END_SRC

** Lisps

   I like to use =paredit= in Lisp modes to balance parentheses (and more!).

   #+BEGIN_SRC emacs-lisp
     (use-package paredit)
   #+END_SRC

	 #+RESULTS:

   =rainbow-delimiters= is convenient for coloring matching parentheses.

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters)
   #+END_SRC

	 #+RESULTS:

   All the lisps have some shared features, so we want to do the same things for
   all of them. That includes using =paredit=, =rainbow-delimiters=, and
   highlighting the whole expression when point is on a parenthesis.

   #+BEGIN_SRC emacs-lisp
     (setq lispy-mode-hooks
           '(clojure-mode-hook
             emacs-lisp-mode-hook
             lisp-mode-hook
             scheme-mode-hook))

     (dolist (hook lispy-mode-hooks)
       (add-hook hook (lambda ()
                        (setq show-paren-style 'expression)
                        (paredit-mode)
                        (rainbow-delimiters-mode))))
   #+END_SRC

	 #+RESULTS:

   If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
   documentation.

   #+BEGIN_SRC emacs-lisp
     (use-package eldoc
       :config
       (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
   #+END_SRC

	 #+RESULTS:
	 : t

   I also like using =flycheck-package= to ensure that my Elisp packages are
   correctly formatted.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-package)

     (eval-after-load 'flycheck
       '(flycheck-package-setup))
   #+END_SRC

** Python

   #+BEGIN_SRC emacs-lisp
     (use-package python-mode)
   #+END_SRC

	 #+RESULTS:

   Add =~/.local/bin= to load path. That's where =virtualenv= is installed, and
   we'll need that for =jedi=.

   #+BEGIN_SRC emacs-lisp
     (ajc/append-to-path "~/.local/bin")
   #+END_SRC

	 #+RESULTS:
	 | ~/.local/bin | ~/.cabal/bin | /bin | /run/wrappers/bin | /home/cmrfrd/.nix-profile/bin | /etc/profiles/per-user/cmrfrd/bin | /nix/var/nix/profiles/default/bin | /run/current-system/sw/bin | /nix/store/s13kiaz3b0xxrsqf7wb5vhj2nfcw280c-emacs-pgtkgcc-20210427.0/libexec/emacs/28.0.50/x86_64-pc-linux-gnu |

   Enable =elpy=. This provides automatic indentation, auto-completion, syntax
   checking, etc.

   #+BEGIN_SRC emacs-lisp
     ;;(use-package elpy)
     ;;(elpy-enable)
   #+END_SRC

	 #+RESULTS:

   Use =flycheck= for syntax checking:

   #+BEGIN_SRC emacs-lisp
     (add-hook 'elpy-mode-hook 'flycheck-mode)
   #+END_SRC

	 #+RESULTS:
	 | py-autopep8-enable-on-save | flycheck-mode |

   Format code according to PEP8 on save:

   #+BEGIN_SRC emacs-lisp
     (use-package py-autopep8)
     (require 'py-autopep8)
     (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
   #+END_SRC

	 #+RESULTS:
	 | py-autopep8-enable-on-save | flycheck-mode |

   Configure Jedi along with the associated =company= mode:

   #+BEGIN_SRC emacs-lisp
                                             ;(use-package company-jedi)
                                             ;(add-to-list 'company-backends 'company-jedi)

                                             ;(add-hook 'python-mode-hook 'jedi:setup)
     (setq jedi:complete-on-dot t)
   #+END_SRC

	 #+RESULTS:
	 : t

   Add anaconda mode

   #+BEGIN_SRC emacs-lisp
     (use-package anaconda-mode
       :ensure anaconda-mode)
     (use-package company-anaconda
       :ensure company-anaconda)
   #+END_SRC

** Rust

   A language empowering everyone to build reliable and efficient software.

   #+begin_src emacs-lisp
     (use-package rust-mode
       :hook (rust-mode . lsp))

     ;; Add keybindings for interacting with Cargo
     (use-package cargo
       :hook (rust-mode . cargo-minor-mode))

     (use-package flycheck-rust
       :config (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
   #+end_src

	 #+RESULTS:
	 : t

** =sh=

   Indent with 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'sh-mode-hook
               (lambda ()
                 (setq sh-basic-offset 2
                       sh-indentation 2)))
   #+END_SRC

** Scala

   Ensure that =scala-mode= and =sbt-mode= are installed.

   #+BEGIN_SRC emacs-lisp
     (use-package scala-mode
       :interpreter
       ("scala" . scala-mode))
     (use-package sbt-mode)
   #+END_SRC

	 #+RESULTS:

   Don't show the startup message with launching ENSIME:

   #+BEGIN_SRC emacs-lisp
     (setq ensime-startup-notification nil)
   #+END_SRC

	 #+RESULTS:

   Bind a few keys to common operations:

   #+BEGIN_SRC emacs-lisp
     ;; (evil-define-key 'normal ensime-mode-map (kbd "C-t") 'ensime-type-at-point)
     ;; (evil-define-key 'normal ensime-mode-map (kbd "M-.") 'ensime-edit-definition)
   #+END_SRC

** =web-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode)
   #+END_SRC

	 #+RESULTS:

   If I'm in =web-mode=, I'd like to:

   - Color color-related words with =rainbow-mode=.
   - Still be able to run RSpec tests from =web-mode= buffers.
   - Indent everything with 2 spaces.

   #+BEGIN_SRC emacs-lisp
                                             ; (add-hook 'web-mode-hook
                                             ;          (lambda ()
                                             ;            (rainbow-mode)
                                             ;            (rspec-mode)
                                             ;            (setq web-mode-markup-indent-offset 2)))
   #+END_SRC

	 #+RESULTS:

   Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

   #+BEGIN_SRC emacs-lisp
     (ajc/add-auto-mode
      'web-mode
      "\\.erb$"
      "\\.html$"
      "\\.php$"
      "\\.rhtml$")
   #+END_SRC

** Typescript
*** Formatter

    Looking at this [[https://patrickskiba.com/emacs/2019/09/07/emacs-for-react-dev.html][blog post]], this guy says to install ~prettier~. His blog
    looks pretty professional so I'm gonna trust him.

    #+begin_src emacs-lisp
      (use-package prettier-js
        :ensure t
        :config
        (setq prettier-js-args '())
                                              ;(setq prettier-js-args '(
                                              ;                         "--trailing-comma" "none"
                                              ;                         "--bracket-spacing" "true"
                                              ;                         "--single-quote" "true"
                                              ;                         "--no-semi" "false"
                                              ;                         "--jsx-single-quote" "true"
                                              ;                         "--jsx-bracket-same-line" "true"
                                              ;                         "--print-width" "100"))
        )
    #+end_src

		#+RESULTS:
		: t

*** Typescript setup

    Typescript is a super awesome language that is definately worth
    using, emacs has only one ide type minor mode for this

    #+BEGIN_SRC emacs-lisp
      (defun setup-tide-mode ()
        "Set up Tide mode."
        (interactive)
        (tide-setup)
        (tide-mode +1)

        (setq flycheck-eslint-args '("--ext" ".js"  "--ext" ".jsx" "--ext" ".ts"  "--ext" ".tsx"))
        (flycheck-mode +1)
                                              ; (flycheck-select-checker 'javascript-eslint)

        (setq flycheck-check-syntax-automatically '(mode-enabled save))
        (eldoc-mode +1)
        (tide-hl-identifier-mode +1)
        (company-mode +1)
        (prettier-js-mode +1)
        ;; (lsp)
        )

      (use-package tide
        :ensure t
        :after (typescript-mode company flycheck)
        :hook ((typescript-mode . tide-setup)
               (typescript-mode . tide-hl-identifier-mode))
        :config
        (setq company-tooltip-align-annotations t)
                                              ; (add-hook 'before-save-hook 'tide-format-before-save)
        (add-hook 'js-mode-hook #'setup-tide-mode)
        (add-hook 'typescript-mode-hook #'setup-tide-mode)
        (flycheck-add-mode 'javascript-eslint 'web-mode)
        (flycheck-add-mode 'tsx-tide 'web-mode)
        (flycheck-add-mode 'typescript-tide 'web-mode)
        (flycheck-add-next-checker 'tsx-tide '(t . javascript-eslint) 'append)
        (flycheck-add-next-checker 'typescript-tide '(t . javascript-eslint) 'append)
        )
    #+END_SRC

		#+RESULTS:

    #+BEGIN_SRC emacs-lisp
      (require 'web-mode)
      (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
      (add-hook 'web-mode-hook
                (lambda ()
                  (when (string-equal "tsx" (file-name-extension buffer-file-name))
                    (setup-tide-mode)
                    (flycheck-select-checker 'tsx-tide))))
      (add-hook 'web-mode-hook
                (lambda ()
                  (when (string-equal "ts" (file-name-extension buffer-file-name))
                    (setup-tide-mode)
                    (flycheck-select-checker 'typescript-tide))))
      (add-to-list 'auto-mode-alist '("\\.ts\\'" . web-mode))

      (add-hook 'web-mode-hook
                (lambda ()
                  (when (string-equal "jsx" (file-name-extension buffer-file-name))
                    (setup-tide-mode))))

      (add-hook 'web-mode-hook
                (lambda ()
                  (when (string-equal "js" (file-name-extension buffer-file-name))
                    (setup-tide-mode))))
    #+END_SRC

		#+RESULTS:
		| lambda | nil | (when (string-equal js (file-name-extension buffer-file-name)) (setup-tide-mode))                                                  |
		| lambda | nil | (when (string-equal jsx (file-name-extension buffer-file-name)) (setup-tide-mode))                                                 |
		| lambda | nil | (when (string-equal ts (file-name-extension buffer-file-name)) (setup-tide-mode) (flycheck-select-checker 'typescript-tide))       |
		| lambda | nil | (when (string-equal tsx (file-name-extension buffer-file-name)) (setup-tide-mode) (flycheck-select-checker 'tsx-tide))             |
		| lambda | nil | (if (string-equal js (file-name-extension buffer-file-name)) (progn (setup-tide-mode)))                                            |
		| lambda | nil | (if (string-equal jsx (file-name-extension buffer-file-name)) (progn (setup-tide-mode)))                                           |
		| lambda | nil | (if (string-equal ts (file-name-extension buffer-file-name)) (progn (setup-tide-mode) (flycheck-select-checker 'typescript-tide))) |
		| lambda | nil | (if (string-equal tsx (file-name-extension buffer-file-name)) (progn (setup-tide-mode) (flycheck-select-checker 'tsx-tide)))       |

** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode)
   #+END_SRC

	 #+RESULTS:

   If I'm editing YAML I'm usually in a Rails project. I'd like to be able to run
   the tests from any buffer.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'yaml-mode-hook 'rspec-mode)
   #+END_SRC

** TOML

   toml is also a format that some langs have

   #+begin_src emacs-lisp
     (use-package toml-mode)
   #+end_src

	 #+RESULTS:

** JSON

   #+begin_src emacs-lisp
     (use-package json-mode
       :ensure t
       :config
       (add-to-list 'auto-mode-alist '("\\.json$" . json-mode)))
   #+end_src

	 #+RESULTS:
	 : t

** Docker

   I work with docker containers alot so it's handy to have highlighting available

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :ensure dockerfile-mode)
     (require 'dockerfile-mode)
     (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode))
     (use-package docker-compose-mode
       :ensure t)
     (use-package docker
       :ensure t)
   #+END_SRC

	 #+RESULTS:

   Also it's nice doing docker stuff in org mode

   #+begin_src emacs-lisp
     (use-package ob-docker-build
       :ensure t
       :straight (ob-docker-build :type git :host github :repo "ifitzpat/ob-docker-build" :branch "master"))
   #+end_src

	 #+RESULTS:

** plantuml
   Plantuml is a handy way to write flow diagrams / uml and other documentation
   like stuff

   #+begin_src emacs-lisp
     (use-package plantuml-mode
       :ensure t
       :config
       (setq plantuml-executable-path (locate-file "plantuml" exec-path exec-suffixes 1))
       (setq org-plantuml-exec-mode 'plantuml)
       (setq plantuml-default-exec-mode 'executable))
   #+end_src

	 #+RESULTS:
	 : t

** markdown

   Markdown is a really cool and handy format which most github repos
   have. It would be nice to make them easily viewable

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t
       :commands (markdown-mode gfm-mode)
       :mode (("README\\.md\\'" . gfm-mode)
              ("\\.md\\'" . markdown-mode)
              ("\\.markdown\\'" . markdown-mode))
       :init (setq markdown-command ""))
   #+END_SRC
** Nix

   #+BEGIN_SRC emacs-lisp
     (use-package nix-mode
       :mode "\\.nix\\'")
   #+END_SRC

** Fish

   #+BEGIN_SRC emacs-lisp
     (use-package fish-mode
       :mode "\\.fish\\'")
   #+END_SRC

** LSP

   LSP sounds really cool [[https://langserver.org/]]

   Sounds like a really useful tool for any modern IDE

   #+begin_src emacs-lisp
     (use-package lsp-mode
       :ensure t
       :config
       (setq read-process-output-max (* 1024 1024))
       (setq lsp-auto-guess-root t        ; Detect project root
             lsp-keep-workspace-alive nil ; Auto-kill LSP server
             lsp-enable-indentation nil
             lsp-enable-on-type-formatting nil
             lsp-keymap-prefix "C-c l")
       )
   #+end_src

	 #+RESULTS:
	 : t

   Now to install the "UI"

   #+begin_src emacs-lisp
     (use-package lsp-ui
       :custom-face
       (lsp-ui-sideline-code-action ((t (:inherit warning))))
       :bind (("C-c u" . lsp-ui-imenu))
       :hook (lsp-mode . lsp-ui-mode)
       :init (setq lsp-ui-doc-enable t
                   lsp-ui-doc-use-webkit nil
                   lsp-ui-doc-delay 0.2
                   lsp-ui-doc-include-signature t
                   lsp-ui-doc-position 'at-point
                   lsp-ui-doc-border (face-foreground 'default)
                   lsp-eldoc-enable-hover nil ; Disable eldoc displays in minibuffer

                   lsp-ui-sideline-enable t
                   lsp-ui-sideline-show-hover nil
                   lsp-ui-sideline-show-diagnostics nil
                   lsp-ui-sideline-ignore-duplicate t

                   lsp-ui-imenu-enable t
                   lsp-ui-imenu-colors `(,(face-foreground 'font-lock-keyword-face)
                                         ,(face-foreground 'font-lock-string-face)
                                         ,(face-foreground 'font-lock-constant-face)
                                         ,(face-foreground 'font-lock-variable-name-face)))
       :config
       (add-to-list 'lsp-ui-doc-frame-parameters '(right-fringe . 8))

       ;; `C-g'to close doc
       (advice-add #'keyboard-quit :before #'lsp-ui-doc-hide)

       ;; Reset `lsp-ui-doc-background' after loading theme
       (add-hook 'after-load-theme-hook
                 (lambda ()
                   (setq lsp-ui-doc-border (face-foreground 'default))
                   (set-face-background 'lsp-ui-doc-background
                                        (face-background 'tooltip))))

       ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
       ;; @see https://github.com/emacs-lsp/lsp-ui/issues/243
       (defun my-lsp-ui-imenu-hide-mode-line ()
         "Hide the mode-line in lsp-ui-imenu."
         (setq mode-line-format nil))
       (advice-add #'lsp-ui-imenu :after #'my-lsp-ui-imenu-hide-mode-line))
   #+end_src

	 #+RESULTS:
	 : lsp-ui-imenu

   Now completion for company

   #+begin_src emacs-lisp
     ;;(use-package company-lsp
     ;;  :init (setq company-lsp-cache-candidates 'auto)
     ;;  :config
     ;;   (with-no-warnings
     ;;     ;; WORKAROUND: Fix tons of unrelated completion candidates shown
     ;;     ;; when a candidate is fulfilled
     ;;     ;; @see https://github.com/emacs-lsp/lsp-python-ms/issues/79
     ;;     (add-to-list 'company-lsp-filter-candidates '(mspyls))

     ;;     (defun my-company-lsp--on-completion (response prefix)
     ;;       "Handle completion RESPONSE.
     ;; PREFIX is a string of the prefix when the completion is requested.
     ;; Return a list of strings as the completion candidates."
     ;;       (let* ((incomplete (and (hash-table-p response) (gethash "isIncomplete" response)))
     ;;              (items (cond ((hash-table-p response) (gethash "items" response))
     ;;                           ((sequencep response) response)))
     ;;              (candidates (mapcar (lambda (item)
     ;;                                    (company-lsp--make-candidate item prefix))
     ;;                                  (lsp--sort-completions items)))
     ;;              (server-id (lsp--client-server-id (lsp--workspace-client lsp--cur-workspace)))
     ;;              (should-filter (or (eq company-lsp-cache-candidates 'auto)
     ;;                                 (and (null company-lsp-cache-candidates)
     ;;                                      (company-lsp--get-config company-lsp-filter-candidates server-id)))))
     ;;         (when (null company-lsp--completion-cache)
     ;;           (add-hook 'company-completion-cancelled-hook #'company-lsp--cleanup-cache nil t)
     ;;           (add-hook 'company-completion-finished-hook #'company-lsp--cleanup-cache nil t))
     ;;         (when (eq company-lsp-cache-candidates 'auto)
     ;;           ;; Only cache candidates on auto mode. If it's t company caches the
     ;;           ;; candidates for us.
     ;;           (company-lsp--cache-put prefix (company-lsp--cache-item-new candidates incomplete)))
     ;;         (if should-filter
     ;;             (company-lsp--filter-candidates candidates prefix)
     ;;           candidates)))
     ;;     (advice-add #'company-lsp--on-completion :override #'my-company-lsp--on-completion)))
   #+end_src

	 #+RESULTS:

   I am a helm user so HELM ALL THE WAY!

   #+begin_src emacs-lisp
                                             ;(use-package helm-lsp
                                             ;  :commands helm-lsp-workspace-symbol)
   #+end_src

	 #+RESULTS:

   python lsp test
   #+begin_src emacs-lisp
     (use-package lsp-python-ms
       :hook (python-mode . (lambda () (require 'lsp-python-ms))))
   #+end_src

** GPG

   Its obvious that encryption is an important and miracle invention.

   I want to have a way to encrypt, store keys, and be pragmatic about using it

   The most generally used solution for this that is extremely function is gpg

   #+begin_src emacs-lisp
     (defun gpg-get-pub-id (email)
       (let* ((key-pair (nth 0 (epg-list-keys (epg-make-context nil t t) email)))
              (keys (epg-key-sub-key-list key-pair))
              (pub-key (--first (equal (list 'sign 'certify) (epg-sub-key-capability it)) keys)))
         (epg-sub-key-id pub-key)))

     ;; gpg stuff
     (defun pinentry-emacs (desc prompt ok error)
       (let ((str (read-passwd
                   (concat
                    (replace-regexp-in-string "%22" "\""
                                              (replace-regexp-in-string "%0A" "\n" desc))
                    prompt ": "))))
         str))
     (setq epa-pinentry-mode 'emacs)
     (setf epa-pinentry-mode 'loopback)
     (setq epg-gpg-program "gpg2")
     (setq epa-file-encrypt-to user-mail-address)
     (setenv "INSIDE_EMACS" (format "%s,comint" emacs-version))
     ;; (pinentry-start)
     (epa-file-enable)
     (setq epa-file-select-keys (gpg-get-pub-id user-mail-address))
     '()
   #+end_src

	 #+RESULTS:

   #+begin_src emacs-lisp
     (org-crypt-use-before-save-magic)
     (setq org-tags-exclude-from-inheritance (quote ("crypt")))
     (setq org-crypt-key (gpg-get-pub-id user-mail-address))
     '()
   #+end_src

	 #+RESULTS:

   #+begin_src emacs-lisp
     (defun org-gpg-encrypt-entry () (interactive) (org-encrypt-entry))
     (defun org-gpg-encrypt-entries () (interactive) (org-encrypt-entries))

     (defun org-gpg-decrypt-entries ()
       (interactive)
       (let ((pw (bitwarden-get-note (format "%s_gpg_key_pw" user-mail-address))))
         (with-simulated-input (list pw "RET") (org-decrypt-entries))))

     (defun org-gpg-decrypt-entry ()
       (interactive)
       (let ((pw (bitwarden-get-note (format "%s_gpg_key_pw" user-mail-address))))
         (with-simulated-input (list pw "RET") (org-decrypt-entry))))
   #+end_src

	 #+RESULTS:
   : org-gpg-decrypt-entry

* Terminal

  For a while I used =shell-pop= for shell sessions but I'm now transitioning
  to using =multi-term= and =vterm= to manage my shell sessions. It's bound to =C-c t=.

  #+BEGIN_SRC emacs-lisp
    (print "Loading terminal configs")
    (use-package multi-term
      :straight t)

    (use-package vterm
      :ensure t)
    (load-file "~/.emacs.d/resources/multi-libvterm.d/multi-libvterm.el")

    (global-set-key (kbd "C-c t") 'multi-libvterm)

    ;; if nix is installed use fish as shell
    (if (file-directory-p "~/.nix-profile/")
        (setq multi-libvterm-program "~/.nix-profile/bin/fish"))
  #+END_SRC

	#+RESULTS:
	: ~/.nix-profile/bin/fish

  Use a login shell:

  #+BEGIN_SRC emacs-lisp
    (setq multi-term-program-switches "--login")
  #+END_SRC

	#+RESULTS:
	: --login

  I'd rather not use Evil in the terminal. It's not especially useful (I don't use
  vi bindings in xterm) and it shadows useful keybindings (=C-d= for EOF, for
  example).

  #+BEGIN_SRC emacs-lisp
                                            ; (evil-set-initial-state 'term-mode 'emacs)
  #+END_SRC

	#+RESULTS:

  I add a bunch of hooks to =term-mode=:

  - I'd like links (URLs, etc) to be clickable.
  - Yanking in =term-mode= doesn't quite work. The text from the paste appears in
    the buffer but isn't sent to the shell process. This correctly binds =C-y= and
    middle-click to yank the way we'd expect.
  - I bind =M-o= to quickly change windows. I'd like that in terminals, too.
  - I don't want to perform =yasnippet= expansion when tab-completing.

  #+begin_src emacs-lisp
    (defun ajc/term-paste (&optional string)
      (interactive)
      (process-send-string
       (get-buffer-process (current-buffer))
       (if string string (current-kill 0))))
  #+end_src

	#+RESULTS:
	: ajc/term-paste

  #+begin_src emacs-lisp
    (global-set-key (kbd "M-n") 'multi-libvterm-next)
    (global-set-key (kbd "M-p") 'multi-libvterm-prev)
    (add-hook 'vterm-mode-hook
              (lambda ()
                (linum-mode 0)
                (goto-address-mode)
                (setq comint-process-echoes t)
                (define-key vterm-mode-map (kbd "M-n") 'multi-libvterm-next)
                (define-key vterm-mode-map (kbd "M-p") 'multi-libvterm-prev)
                (defun vterm-send-Cright ()
                  (interactive)
                  (vterm-send-key "<right>" nil nil t))
                (defun vterm-send-Cleft  ()
                  (interactive)
                  (vterm-send-key "<left>" nil nil t))
                (define-key vterm-mode-map (kbd "C-<right>")      'vterm-send-Cright)
                (define-key vterm-mode-map (kbd "C-<left>")       'vterm-send-Cleft)
                (define-key vterm-mode-map (kbd "C-y") 'ajc/term-paste)
                (define-key vterm-mode-map (kbd "C-q") nil)))
  #+end_src

	#+RESULTS:
	| lambda | nil | (linum-mode 0) | (goto-address-mode) | (setq comint-process-echoes t) | (define-key vterm-mode-map (kbd M-n) 'multi-libvterm-next) | (define-key vterm-mode-map (kbd M-p) 'multi-libvterm-prev) | (defun vterm-send-Cright nil (interactive) (vterm-send-key <right> nil nil t)) | (defun vterm-send-Cleft nil (interactive) (vterm-send-key <left> nil nil t)) | (define-key vterm-mode-map (kbd C-<right>) 'vterm-send-Cright) | (define-key vterm-mode-map (kbd C-<left>) 'vterm-send-Cleft) | (define-key vterm-mode-map (kbd C-y) 'ajc/term-paste) | (define-key vterm-mode-map (kbd C-q) nil) |

  #+BEGIN_SRC emacs-lisp
    (add-hook 'term-mode-hook
              (lambda ()
                (linum-mode 0)
                (goto-address-mode)
                (setq comint-process-echoes t)
                (define-key term-raw-map (kbd "C-y") 'ajc/term-paste)
                (define-key term-raw-map (kbd "<mouse-2>") 'ajc/term-paste)
                (define-key term-raw-map (kbd "M-o") 'other-window)
                (define-key term-raw-map (kbd "M-n") 'multi-term-next)
                (define-key term-raw-map (kbd "M-p") 'multi-term-prev)
                (defun term-send-Cr () (interactive) (term-send-raw-string "\C-r"))
                                            ;(evil-local-set-key 'insert (kbd "C-r") 'term-send-Cr)
                (define-key term-raw-map (kbd "C-r")      'term-send-Cr)
                (defun term-send-tab () (interactive) (term-send-raw-string "\t") )
                (define-key term-raw-map (kbd "TAB")      'term-send-tab)
                (define-key term-raw-map (kbd "<tab>")      'term-send-tab)
                (defun term-send-Cspc () (interactive) (term-send-raw-string (string 0)))
                (define-key term-raw-map (kbd "M-SPC") 'term-send-Cspc)
                (define-key term-raw-map (kbd "C-t") 'term-send-Cspc)
                (setq indent-tabs-mode nil)
                (setq tab-width 0)
                (defun term-send-Cright () (interactive) (term-send-raw-string "\e[1;5C"))
                (defun term-send-Cleft  () (interactive) (term-send-raw-string "\e[1;5D"))
                (define-key term-raw-map (kbd "C-<right>")      'term-send-Cright)
                (define-key term-raw-map (kbd "C-<left>")       'term-send-Cleft)
                (yas-minor-mode -1)
                (setq global-hl-line-mode nil)
                (setq bidi-paragraph-direction 'left-to-right)
                ))
  #+END_SRC

	#+RESULTS:
	| lambda | nil | (linum-mode 0) | (goto-address-mode) | (setq comint-process-echoes t) | (define-key term-raw-map (kbd C-y) 'ajc/term-paste) | (define-key term-raw-map (kbd <mouse-2>) 'ajc/term-paste) | (define-key term-raw-map (kbd M-o) 'other-window) | (define-key term-raw-map (kbd M-n) 'multi-term-next) | (define-key term-raw-map (kbd M-p) 'multi-term-prev) | (defun term-send-Cr nil (interactive) (term-send-raw-string )) | (define-key term-raw-map (kbd C-r) 'term-send-Cr) | (defun term-send-tab nil (interactive) (term-send-raw-string 	)) | (define-key term-raw-map (kbd TAB) 'term-send-tab) | (define-key term-raw-map (kbd <tab>) 'term-send-tab) | (defun term-send-Cspc nil (interactive) (term-send-raw-string (string 0))) | (define-key term-raw-map (kbd M-SPC) 'term-send-Cspc) | (define-key term-raw-map (kbd C-t) 'term-send-Cspc) | (setq indent-tabs-mode nil) | (setq tab-width 0) | (defun term-send-Cright nil (interactive) (term-send-raw-string [1;5C)) | (defun term-send-Cleft nil (interactive) (term-send-raw-string [1;5D)) | (define-key term-raw-map (kbd C-<right>) 'term-send-Cright) | (define-key term-raw-map (kbd C-<left>) 'term-send-Cleft) | (yas-minor-mode -1) | (setq global-hl-line-mode nil) | (setq bidi-paragraph-direction 'left-to-right) |

  I have this really cool function so I can send regions to a terminal. Really
  andy when you want to execute selections without copying and pasting

  #+BEGIN_SRC emacs-lisp
    ;;
    ;; Send region to running emacs process
    ;;
    (global-set-key (kbd "C-u") #'tws-region-to-process)
    (defun tws-region-to-process (arg beg end)
      "Send the current region to a process buffer.
    The first time it's called, will prompt for the buffer to
    send to. Subsequent calls send to the same buffer, unless a
    prefix argument is used (C-u), or the buffer no longer has an
    active process."
      (interactive "P\nr")
      (when (or arg ;; user asks for selection
                (not (boundp 'tws-process-target)) ;; target not set
                ;; or target is not set to an active process:
                (not (process-live-p (get-buffer-process tws-process-target))))
        (let (procs buf)
          (setq procs (remove nil (seq-map
                                   (lambda (el)
                                     (when (setq buf (process-buffer el))
                                       (buffer-name buf)))
                                   (process-list))))
          (if (not procs) (error "No process buffers currently open.")
            (setq tws-process-target (completing-read "Process: " procs)))))
                                            ;(process-send-region tws-process-target beg end))
      (process-send-string tws-process-target (buffer-substring beg end)))
  #+END_SRC

	#+RESULTS:
	: tws-region-to-process

  Sometimes I want to cut things from the terminal into another buffer,
  so here I can switch from one to another

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c C-j") 'term-line-mode)
    (global-set-key (kbd "C-c C-k") 'term-char-mode)
  #+END_SRC

	#+RESULTS:
	: term-char-mode

* Org

** Org base

   First we will define some high level 'constants' related to org

   #+begin_src emacs-lisp
     (setq org-directory "~/org/")
     (setq org-journal-directory (f-join org-directory "journal"))
     (setq org-roam-directory org-directory)

     ;; Roam related directories (relative to org dir)
     (setq org-roam-link-dir "links/${slug}")
     (setq org-map-dir (f-join "map" "${slug}"))
   #+end_src

	 #+RESULTS:
   : map/${slug}

   Now we will setup the visual based settings for org mode

   #+begin_src emacs-lisp
     ;; I like seeing a little downward-pointing arrow instead of the usual ellipsis
     ;; (=...=) that org displays when there's stuff under a header.
     (setq org-ellipsis "")

     ;; Use syntax highlighting in source blocks while editing.
     (setq org-src-fontify-natively t)

     ;; Make TAB act as if it were issued in a buffer of the language's major mode.
     (setq org-src-tab-acts-natively t)

     ;; When editing a code snippet, use the current window rather than popping open a
     ;; new one (which shows the same information).
     (setq org-src-window-setup 'current-window)

     ;; I like shift selection, importing old knowledge...
     (setq org-support-shift-select t)

   #+end_src

	 #+RESULTS:
	 : t

   Now we will define some useful functions for path manipulation, repo management, etc.

   #+begin_src emacs-lisp
     ;; Setup main org repo
     (defun ajc/setup-org-repo ()
       "Install org "
       (interactive)
       (let ((auto-answer t))
         (if (not (f-dir? org-directory))
             (magit-clone-regular "git@github.com:cmrfrd/org.git" (getenv "HOME") '()))))


     ;; Appenda  filename to the root org dir
     (defun org-file-path (filename)
       "Return the absolute address of an org file, given its relative name."
       (concat (file-name-as-directory org-directory) filename))
   #+end_src

	 #+RESULTS:
	 : org-file-path

** Setup org

   Now we will setup base org mode

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure org-plus-contrib
       :hook
       (before-save . zp/org-set-last-modified))

     (push 'company-capf company-backends)

     (defun add-pcomplete-to-capf ()
       (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))

     (add-hook 'org-mode-hook #'add-pcomplete-to-capf)
   #+END_SRC

	 #+RESULTS:
	 | add-pcomplete-to-capf | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | evil-org-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | org-eldoc-load |

   Now we will add some hooks

   #+begin_src emacs-lisp
     ;; specific thing with italics and stuff
     (with-eval-after-load 'org
       (setcar (nthcdr 4 org-emphasis-regexp-components) 10)
       (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components))

     (add-to-list 'org-modules 'org-tempo)
     (add-hook 'org-mode-hook
               (lambda ()
                 (require 'org-tempo)))
   #+end_src

	 #+RESULTS:
	 | (lambda nil (require 'org-tempo)) | add-pcomplete-to-capf | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | evil-org-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | org-eldoc-load |

   Now we will install all the frivolous org package

   #+begin_src emacs-lisp
     (use-package ox-reveal :ensure t)
     (use-package ob-go :ensure t)
     (use-package ob-ipython :ensure t)
     (use-package ox-gfm
       :ensure t
       :config
       (eval-after-load "org"
         '(require 'ox-gfm nil t)))
     (use-package ox-hugo
       :ensure t
       :config
       (eval-after-load "org"
         '(require 'ox-hugo nil t)))
     (use-package org-bullets
       :init
       (add-hook 'org-mode-hook 'org-bullets-mode))
   #+end_src

   #+RESULTS:

** Org journal
	 #+RESULTS:


   I prefer org journal over org roam dailies to store notes.

   #+begin_src emacs-lisp
     (use-package org-journal
       :bind
       ("C-c j" . org-journal-new-entry)
       :custom
       (org-journal-dir org-journal-directory)
       (org-journal-file-format "%Y-%m-%d.org")
       ;; (org-journal-enable-agenda-integration t)
       (org-journal-carryover-items nil)
       (org-journal-date-format "%A, %d %B %Y")
       (org-journal-date-prefix "")
       (org-journal-file-header "#+TITLE: Journal %A, %d %B %Y\n#+STARTUP: folded\n#+ROAM_TAGS: journal"))
   #+end_src

	 #+RESULTS:
	 : org-journal-new-entry

   These are some handy functions

   #+begin_src emacs-lisp
     (defun org-journal-today ()
       ;; For creating a new entry for today
       (interactive)
       (org-journal-new-entry t))

     (defun org-journal-find-location ()
       ;; Open today's journal, but specify a non-nil prefix argument in order to
       ;; inhibit inserting the heading; org-capture will insert the heading.
       (org-journal-new-entry t)
       (unless (eq org-journal-file-type 'daily)
         (org-narrow-to-subtree))
       (goto-char (point-max)))
   #+end_src

	 #+RESULTS:
	 : org-journal-find-location

** Org roam

   #+begin_src emacs-lisp
     (use-package org-roam
       :ensure t
       :hook (after-init . org-roam-mode)
       :bind (:map org-roam-mode-map
                   (("C-c r l" . org-roam)
                    ("C-c r r" . org-roam-buffer-toggle-display)
                    ("C-c r c" . org-roam-capture)
                    ("C-c r f" . org-roam-find-file)
                    ("C-c r d" . org-roam-find-directory)
                    ("C-c r b" . org-roam-switch-to-buffer)
                    ("C-c r g" . org-roam-graph))
                   :map org-mode-map
                   (("C-c r i" . org-roam-insert)
                    ("C-c r I" . org-roam-insert-immediate)
                    ("C-c r l" . org-roam)
                    ("C-c r r" . org-roam-buffer-toggle-display)
                    ("C-c r c" . org-roam-capture)
                    ("C-c r f" . org-roam-find-file)
                    ("C-c r d" . org-roam-find-directory)
                    ("C-c r b" . org-roam-switch-to-buffer)
                    ("C-c r g" . org-roam-graph)))
       :config
       (setq org-roam-buffer "Org-roam Sidebar")
       (setq org-roam-encrypt-files nil)

       ;; use company as org roam backend
       ;; (use-package company-org-roam
       ;;   :ensure t
       ;;   :config
       ;;   (push 'company-org-roam company-backends))

       ;; use org protocol so we can use bookmarklets
       (require 'org-roam-protocol)

       ;; Set the initial variables and hooks for configuration
       (setq org-id-link-to-org-use-id t
             org-roam-tag-sources '(prop last-directory))

       ;; Configure tmplates for org roam
       (setq org-roam-capture-ref-templates
             '(("r" "ref" plain (function org-roam-capture--get-point)
                "\n%?"
                :file-name "links/${slug}"
                :head "#+TITLE: ${title}\n#+CREATED: %U\n#+LAST_MODIFIED: %U\n#+ROAM_KEY: ${ref}\n#+ROAM_TAGS: website\n- source :: ${ref}"
                :unnarrowed t)
               ("rn" "ref-now" plain (function org-roam-capture--get-point)
                "%?"
                :file-name "links/${slug}"
                :head "#+TITLE: ${title}\n#+CREATED: %U\n#+LAST_MODIFIED: %U\n#+ROAM_KEY: ${ref}\n#+ROAM_TAGS: website\n- source :: ${ref}"
                :unnarrowed t :immediate-finish t)))
       )
   #+end_src

	 #+RESULTS:
   : org-roam-graph

** Org roam server

   #+begin_src emacs-lisp
     (use-package org-roam-server
       :after org-roam
       :config
       (setq org-roam-server-host "127.0.0.1"
             org-roam-server-port 8080
             org-roam-server-export-inline-images t
             org-roam-server-authenticate nil
             org-roam-server-label-truncate t
             org-roam-server-label-truncate-length 60
             org-roam-server-label-wrap-length 20)
       (defun org-roam-server-open ()
         "Ensure the server is active, then open the roam graph."
         (interactive)
         (org-roam-server-mode 1)
         (browse-url-xdg-open (format "http://localhost:%d" org-roam-server-port))))
   #+end_src

	 #+RESULTS:

** Deft

   Cool interface for searching through files

   #+begin_src emacs-lisp
     ;; (use-package deft
     ;;   :straight (deft
     ;;               :type git :host github
     ;;               :repo "jrblevin/deft"
     ;;               :fork (:host github
     ;;                            :repo "credmp/deft"))
     ;;   :after org
     ;;   :bind
     ;;   ("C-c d" . deft)
     ;;   :custom
     ;;   (deft-recursive t)
     ;;   (deft-use-filter-string-for-filename t)
     ;;   (deft-default-extension "org")
     ;;   (deft-directory org-directory ))
   #+end_src

	 #+RESULTS:

** Org bibtex

   #+begin_src emacs-lisp
     (use-package helm-bibtex
       :ensure t)

     (use-package org-roam-bibtex
       :after org-roam
       :hook (org-roam-mode . org-roam-bibtex-mode))

     (use-package org-ref
       :after org
       :init
       (make-directory (f-join org-directory "bibliography") :parent)
       (setq org-ref-bibliography-notes (f-join org-directory "bibliography" "notes.org"))
       (setq bibtex-completion-notes-path (f-join org-directory "bibliography" "notes.org"))
       (setq reftex-default-bibliography (f-join org-directory "bibliography" "library.bib"))
       (setq org-ref-default-bibliography (f-join org-directory "bibliography" "library.bib"))
       (setq org-ref-pdf-directory (f-join org-directory "pdfs")))
   #+end_src

	 #+RESULTS:

** Task and org-capture management

   Store my org files in =notes/org=, maintain an inbox in Dropbox, define
   the location of an index file (my main todo list), and archive finished tasks in
   =notes/org/archive.org=.

   #+BEGIN_SRC emacs-lisp
     (setq org-inbox-file (org-file-path "inbox.org"))
     (setq org-index-file (org-file-path "index.org"))
     (setq org-archive-location
           (concat (org-file-path "archive.org") "::* From %s"))
   #+END_SRC

	 #+RESULTS:
	 : ~/org/archive.org::* From %s

   I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
   append them to an "inbox.org" file in my Dropbox. This function lets me import
   them easily from that inbox file to my index.

   #+BEGIN_SRC emacs-lisp
     (defun ajc/copy-tasks-from-inbox ()
       (when (file-exists-p org-inbox-file)
         (save-excursion
           (find-file org-index-file)
           (goto-char (point-max))
           (insert-file-contents org-inbox-file)
           (delete-file org-inbox-file))))
   #+END_SRC

	 #+RESULTS:
	 : ajc/copy-tasks-from-inbox

   I store all my todos in =index.org=, so I'd like to derive my
   agenda from there.

   #+BEGIN_SRC emacs-lisp
                                             ; (setq org-agenda-files (list org-index-file))
   #+END_SRC

	 #+RESULTS:

   Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
   place in the archive.

   #+BEGIN_SRC emacs-lisp
     (defun ajc/mark-done-and-archive ()
       "Mark the state of an org-mode item as DONE and archive it."
       (interactive)
       (org-todo 'done)
       (org-archive-subtree))

     (define-key org-mode-map (kbd "C-c C-x C-s") 'ajc/mark-done-and-archive)
   #+END_SRC

	 #+RESULTS:
	 : ajc/mark-done-and-archive

   Record the time that a todo was archived.

   #+BEGIN_SRC emacs-lisp
     (setq org-log-done 'time)
   #+END_SRC

**** Capturing tasks

     Define a few common tasks as capture templates. Specifically, I frequently:
     - Record ideas for future blog posts in =notes/blog-ideas.org=,
     - Maintain a todo list in =notes/index.org=.
     - Convert emails into todos to maintain an empty inbox.

     #+BEGIN_SRC emacs-lisp :results value verbatim
       (setq org-protocol-default-template-key "l")
       (use-package org-cliplink
         :ensure t)

       ;; (setq org-links-file (f-join org-directory "links.org"))
       ;; https://github.com/jethrokuan/.emacs.d/blob/master/init.el
       (defun read-filename ()
         (interactive)
         (setq org-file--name (s-replace-all '((" " . "_")) (read-string "Name: ")))
         (f-join org-directory "map" (format "%s.org" org-file--name)))

       (setq org-capture-templates
             '(("f" "fleeting" plain (file read-filename)
                "%(format \"#+TITLE: %s\n#+CREATED: %U\n#+LAST_MODIFIED: %U\n#+ROAM_TAGS: fleeting\n\" org-file--name)"
                :jump-to-captured t)
               ("c" "concept" plain (file read-filename)
                "%(format \"#+TITLE: %s\n#+CREATED: %U\n#+LAST_MODIFIED: %U\n#+ROAM_TAGS: concept\n\" org-file--name)"
                :jump-to-captured t)
               ("C" "composition" plain (file read-filename)
                "%(format \"#+TITLE: %s\n#+CREATED: %U\n#+LAST_MODIFIED: %U\n#+ROAM_TAGS: composition\n\" org-file--name)"
                :jump-to-captured t)
               ("j" "Journal entry" plain (function org-journal-find-location)
                "** %(format-time-string org-journal-time-format)%^{Title}\n%i%?"
                :jump-to-captured t :immediate-finish t)))

       (defun org-roam-replace-tag (tag replacement)
         (progn
           (org-roam-tag-delete tag)
           (org-roam-tag-add replacement)))

       (defun ajc/promote-fleeting-to-concept () (interactive) (org-roam-replace-tag "fleeting" "concept"))
       (defun ajc/promote-concept-to-composition () (interactive) (org-roam-replace-tag "concept" "composition"))

       (defun ajc/demote-composition-to-concept () (interactive) (org-roam-replace-tag "composition" "concept"))
       (defun ajc/demote-concept-to-fleeting () (interactive) (org-roam-replace-tag "concept" "fleeting"))
     #+END_SRC

		 #+RESULTS:
     : ajc/demote-concept-to-fleeting


     When I'm starting an Org capture template I'd like to begin in insert mode. I'm
     opening it up in order to start typing something, so this skips a step.

     #+BEGIN_SRC emacs-lisp
                                               ; (add-hook 'org-capture-mode-hook 'evil-insert-state)
     #+END_SRC

		 #+RESULTS:

     Refiling according to the document's hierarchy.

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-use-outline-path t)
       (setq org-outline-path-complete-in-steps nil)
     #+END_SRC

		 #+RESULTS:

**** Keybindings

     Bind a few handy keys.

     #+BEGIN_SRC emacs-lisp
       (define-key global-map "\C-cl" 'org-store-link)
       (define-key global-map "\C-ca" 'org-agenda)
       (define-key global-map "\C-cc" 'org-capture)
     #+END_SRC

		 #+RESULTS:
		 : org-capture

     Hit =C-c i= to quickly open up my todo list.

     #+BEGIN_SRC emacs-lisp
       (defun ajc/open-index-file ()
         "Open the master org TODO list."
         (interactive)
         (ajc/copy-tasks-from-inbox)
         (find-file org-index-file)
         (flycheck-mode -1)
         (end-of-buffer))

       (global-set-key (kbd "C-c i") 'ajc/open-index-file)
     #+END_SRC

		 #+RESULTS:
		 : ajc/open-index-file

     Hit =C-c n= to quickly open up a capture template for a new todo.

     #+BEGIN_SRC emacs-lisp
                                               ;(defun org-capture-todo ()
                                               ;  (interactive)
                                               ;  (org-capture :keys "t"))

                                               ;(global-set-key (kbd "C-c n") 'org-capture-todo)

       ;; (add-hook 'gfm-mode-hook
       ;;           (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
       ;; (add-hook 'haskell-mode-hook
       ;;           (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
     #+END_SRC

		 #+RESULTS:

** Exporting

   Allow export to markdown and beamer (for presentations).

   #+BEGIN_SRC emacs-lisp
     (require 'ox-md)
     (require 'ox-beamer)
   #+END_SRC

	 #+RESULTS:
	 : ox-beamer

   Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

   #+BEGIN_SRC emacs-lisp
     (use-package gnuplot)

     (setq org-babel-inline-result-wrap "%s")
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (ruby . t)
        (shell . t)
        (plantuml . t)
        (dot . t)
        (docker-build . t)
        (gnuplot . t)))
   #+END_SRC

	 #+RESULTS:

   Associate the "dot" language with the =graphviz-dot= major mode.

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode)
     (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
   #+END_SRC

	 #+RESULTS:
	 : ((dot . graphviz-dot) (redis . redis) (php . php) (arduino . arduino) (C . c) (C++ . c++) (asymptote . asy) (bash . sh) (beamer . latex) (calc . fundamental) (cpp . c++) (ditaa . artist) (dot . fundamental) (elisp . emacs-lisp) (ocaml . tuareg) (screen . shell-script) (shell . sh) (sqlite . sql))

   Translate regular ol' straight quotes to typographically-correct curly quotes
   when exporting.

   #+BEGIN_SRC emacs-lisp
     (setq org-export-with-smart-quotes t)
   #+END_SRC

	 #+RESULTS:
	 : t

**** Exporting to HTML

     Don't include a footer with my contact and publishing information at the bottom
     of every exported HTML document.

     #+BEGIN_SRC emacs-lisp
       (setq org-html-postamble nil)
     #+END_SRC

		 #+RESULTS:

     Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
     which checks the =$BROWSER= environment variable to choose the right browser.
     I'd like to always use Firefox, so:

     #+BEGIN_SRC emacs-lisp
       (setq browse-url-browser-function 'browse-url-generic
             browse-url-generic-program "brave")

       (setenv "BROWSER" "brave")
     #+END_SRC

		 #+RESULTS:
		 : brave

**** Exporting to PDF

     I want to produce PDFs with syntax highlighting in the code. The best way to do
     that seems to be with the =minted= package, but that package shells out to
     =pygments= to do the actual work. =pdflatex= usually disallows shell commands;
     this enables that.

     #+BEGIN_SRC emacs-lisp
       (setq org-latex-pdf-process
             '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
               "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
               "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
     #+END_SRC

		 #+RESULTS:
		 | xelatex -shell-escape -interaction nonstopmode -output-directory %o %f | xelatex -shell-escape -interaction nonstopmode -output-directory %o %f | xelatex -shell-escape -interaction nonstopmode -output-directory %o %f |

     Include the =minted= package in all of my LaTeX exports.

     #+BEGIN_SRC emacs-lisp
       (add-to-list 'org-latex-packages-alist '("" "minted"))
       (setq org-latex-listings 'minted)
     #+END_SRC

** TeX configuration
	 #+RESULTS:
	 : minted


   I rarely write LaTeX directly any more, but I often export through it with
   org-mode, so I'm keeping them together.

   Automatically parse the file after loading it.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-parse-self t)
   #+END_SRC

	 #+RESULTS:
	 : t

   Always use =pdflatex= when compiling LaTeX documents. I don't really have any
   use for DVIs.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-PDF-mode t)
   #+END_SRC

	 #+RESULTS:
	 : t

   Open compiled PDFs in =zathura= instead of in the editor.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
               '(lambda ()
                  (delete '("\\.pdf\\'" . default) org-file-apps)
                  (add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s"))))
   #+END_SRC

	 #+RESULTS:
	 | (lambda nil (delete '(\.pdf\' . default) org-file-apps) (add-to-list 'org-file-apps '(\.pdf\' . zathura %s))) | org-ref-org-menu | org-bullets-mode | org-tempo-setup | (lambda nil (require 'org-tempo)) | add-pcomplete-to-capf | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | evil-org-mode | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | org-eldoc-load | org-ref-setup-label-finders |

   Enable a minor mode for dealing with math (it adds a few useful keybindings),
   and always treat the current file as the "main" file. That's intentional, since
   I'm usually actually in an org document.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'LaTeX-mode-hook
               (lambda ()
                 (LaTeX-math-mode)
                 (setq TeX-master t)))
   #+END_SRC

** Kanban
	 #+RESULTS:
	 | lambda | nil | (LaTeX-math-mode) | (setq TeX-master t) |


   #+BEGIN_SRC emacs-lisp
     (use-package org-kanban
       :config
       (define-key global-map (kbd "C-c k") 'org-kanban/shift)
       )
   #+END_SRC

	 #+RESULTS:
	 : t

* =dired=

  Hide dotfiles by default, but toggle their visibility with =.=.

  #+BEGIN_SRC emacs-lisp
    (use-package dired-hide-dotfiles
      :config
      (dired-hide-dotfiles-mode)
      (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
  #+END_SRC

	#+RESULTS:
	: t

  Open media with the appropriate programs.

  #+BEGIN_SRC emacs-lisp
    (use-package dired-open
      :config
      (setq dired-open-extensions
            '(("pdf" . "zathura")
              ("mkv" . "vlc")
              ("mp3" . "vlc")
              ("mp4" . "vlc")
              ("avi" . "vlc"))))
  #+END_SRC

	#+RESULTS:
	: t

  These are the switches that get passed to =ls= when =dired= gets a list of
  files. We're using:

  - =l=: Use the long listing format.
  - =h=: Use human-readable sizes.
  - =v=: Sort numbers naturally.
  - =A=: Almost all. Doesn't include "=.=" or "=..=".

    #+BEGIN_SRC emacs-lisp
      (setq-default dired-listing-switches "-lhvA")
    #+END_SRC

	  #+RESULTS:
	  : -lhvA

    Use "j" and "k" to move around in =dired=.

    #+BEGIN_SRC emacs-lisp
      ;; (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
      ;; (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
    #+END_SRC

	  #+RESULTS:

    Kill buffers of files/directories that are deleted in =dired=.

    #+BEGIN_SRC emacs-lisp
      (setq dired-clean-up-buffers-too t)
    #+END_SRC

	  #+RESULTS:
	  : t

    Always copy directories recursively instead of asking every time.

    #+BEGIN_SRC emacs-lisp
      (setq dired-recursive-copies 'always)
    #+END_SRC

	  #+RESULTS:
	  : always

    Ask before recursively /deleting/ a directory, though.

    #+BEGIN_SRC emacs-lisp
      (setq dired-recursive-deletes 'top)
    #+END_SRC

	  #+RESULTS:
	  : top

    Open a file with an external program (that is, through =xdg-open=) by hitting
    =C-c C-o=.

    #+BEGIN_SRC emacs-lisp
      (defun dired-xdg-open ()
        "In dired, open the file named on this line."
        (interactive)
        (let* ((file (dired-get-filename nil t)))
          (call-process "xdg-open" nil 0 nil file)))

      (define-key dired-mode-map (kbd "C-c C-o") 'dired-xdg-open)
    #+END_SRC

	  #+RESULTS:
	  : dired-xdg-open


* Editing settings
** Quickly visit Emacs configuration
   #+BEGIN_SRC emacs-lisp
     (use-package ranger
       :ensure ranger)
     (ranger-override-dired-mode t)
   #+END_SRC

	 #+RESULTS:
	 : t


   I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
   Emacs configuration file.

   #+BEGIN_SRC emacs-lisp
     (defun ajc/visit-emacs-config ()
       (interactive)
       (find-file "~/.emacs.d/mainconfig.org"))

     (global-set-key (kbd "C-c e") 'ajc/visit-emacs-config)
   #+END_SRC

** Always kill current buffer

   Assume that I always want to kill the current buffer when hitting =C-x k=.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x k") 'ajc/kill-current-buffer)
   #+END_SRC

** Rename buffer and file

   Sometimes it's handy to rename the current file and buffer
   when the name is not appropriate

   #+BEGIN_SRC emacs-lisp
     (defun rename-file-and-buffer (new-name)
       "Renames both current buffer and file it's visiting to NEW-NAME."
       (interactive "sNew name: ")
       (let ((name (buffer-name))
             (filename (buffer-file-name)))
         (if (not filename)
             (message "Buffer '%s' is not visiting a file!" name)
           (if (get-buffer new-name)
               (message "A buffer named '%s' already exists!" new-name)
             (progn
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil))))))
   #+END_SRC

** Set up =helpful=

   The =helpful= package provides, among other things, more context in Help
   buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package helpful)

     (global-set-key (kbd "C-h f") #'helpful-callable)
     (global-set-key (kbd "C-h v") #'helpful-variable)
     (global-set-key (kbd "C-h k") #'helpful-key)
     ;; (evil-define-key 'normal helpful-mode-map (kbd "q") 'quit-window)
   #+END_SRC

** Look for executables in =/usr/local/bin=

   #+BEGIN_SRC emacs-lisp
     (ajc/append-to-path "/usr/local/bin")
   #+END_SRC

** Save my location within a file

   Using =save-place-mode= saves the location of point for every file I visit. If I
   close the file or close the editor, then later re-open it, point will be at the
   last place I visited.

   #+BEGIN_SRC emacs-lisp
     (save-place-mode t)
   #+END_SRC

** Always indent with spaces

   Never use tabs. Tabs are the devils whitespace.

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Move lines up and down

   Sometimes its super handy to move individual lines up and down

   #+BEGIN_SRC emacs-lisp
     (defun move-text-internal (arg)
       (cond
        ((and mark-active transient-mark-mode)
         (if (> (point) (mark))
             (exchange-point-and-mark))
         (let ((column (current-column))
               (text (delete-and-extract-region (point) (mark))))
           (forward-line arg)
           (move-to-column column t)
           (set-mark (point))
           (insert text)
           (exchange-point-and-mark)
           (setq deactivate-mark nil)))
        (t
         (beginning-of-line)
         (when (or (> arg 0) (not (bobp)))
           (forward-line)
           (when (or (< arg 0) (not (eobp)))
             (transpose-lines arg))
           (forward-line -1)))))

     (defun move-text-down (arg)
       "Move region (transient-mark-mode active) or current line
       arg lines down."
       (interactive "*p")
       (move-text-internal arg))

     (defun move-text-up (arg)
       "Move region (transient-mark-mode active) or current line
       arg lines up."
       (interactive "*p")
       (move-text-internal (- arg)))

     (global-set-key [\C-\S-up] 'move-text-up)
     (global-set-key [\C-\S-down] 'move-text-down)
   #+END_SRC

   #+RESULTS:
   : move-text-down

** Synonyms

   #+begin_src emacs-lisp
     (use-package synosaurus
       :diminish synosaurus-mode
       :init    (synosaurus-mode)
       :config  (setq synosaurus-choose-method 'popup) ;; 'ido is default.
       (global-set-key (kbd "M-#") 'synosaurus-choose-and-replace)
       )
   #+end_src

   #+RESULTS:
   : t

** Install and configure =which-key=

   =which-key= displays the possible completions for a long keybinding. That's
   really helpful for some modes (like =projectile=, for example).

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config (which-key-mode))
   #+END_SRC

** Configure =yasnippet=

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet :ensure t)
     (add-to-list 'company-backends 'company-yasnippet)
   #+END_SRC

   #+RESULTS:
   | company-yasnippet | company-capf | company-bbdb | company-semantic | company-cmake | company-capf | company-clang | company-files | (company-dabbrev-code company-gtags company-etags company-keywords) | company-oddmuse | company-dabbrev |

   I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
   enabled.

   #+BEGIN_SRC emacs-lisp
                                             ; (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
     (yas-global-mode 1)
   #+END_SRC

   #+RESULTS:
   : t

   I /dont/ want =yas= to automatically indent the snippets it inserts. Sometimes
   this looks pretty bad (when indenting org-mode, for example, or trying to guess
   at the correct indentation for Python).

   #+BEGIN_SRC emacs-lisp
     (setq yas/indent-line nil)
   #+END_SRC

** Configure =ivy= and =counsel=

   I use =ivy= and =counsel= as my completion framework.

   This configuration:

   - Uses =counsel-M-x= for command completion,
   - Replaces =isearch= with =swiper=,
   - Uses =smex= to maintain history,
   - Enables fuzzy matching everywhere except swiper (where it's thoroughly
     unhelpful), and
   - Includes recent files in the switch buffer.

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :straight t
       :bind
       ("M-X" . 'counsel-M-x)
       ("C-s" . 'swiper)

       :config
       (use-package flx)
       (use-package smex)
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       (setq ivy-initial-inputs-alist nil)
       (setq ivy-re-builders-alist
             '((swiper . ivy--regex-plus)
               (t . ivy--regex-fuzzy))))
   #+END_SRC

   #+RESULTS:
   : swiper

** Switch and rebalance windows when splitting

   When splitting a window, I invariably want to switch to the new window. This
   makes that automatic.

   #+BEGIN_SRC emacs-lisp
     (defun ajc/split-window-below-and-switch ()
       "Split the window horizontally, then switch to the new pane."
       (interactive)
       (split-window-below)
       (other-window 1))

     (defun ajc/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (other-window 1))

     (global-set-key (kbd "C-x 2") 'ajc/split-window-below-and-switch)
     (global-set-key (kbd "C-x 3") 'ajc/split-window-right-and-switch)
   #+END_SRC

   #+RESULTS:
   : ajc/split-window-right-and-switch

** Mass editing of =grep= results

   I like the idea of mass editing =grep= results the same way I can edit filenames
   in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
   results and =C-c C-c= to stop, just like in =dired=.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep)

     (eval-after-load 'grep
       '(define-key grep-mode-map
          (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

     (eval-after-load 'wgrep
       '(define-key grep-mode-map
          (kbd "C-c C-c") 'wgrep-finish-edit))

     (setq wgrep-auto-save-buffer t)
   #+END_SRC

** Use projectile everywhere

   #+BEGIN_SRC emacs-lisp
     (projectile-global-mode)
   #+END_SRC

** Add a bunch of engines for =engine-mode=

   Enable [[https://github.com/ajc/engine-mode][engine-mode]] and define a few useful engines.

   #+BEGIN_SRC emacs-lisp
     (use-package engine-mode)
     (require 'engine-mode)

     (defengine duckduckgo
       "https://duckduckgo.com/?q=%s"
       :keybinding "d")

     (defengine github
       "https://github.com/search?ref=simplesearch&q=%s"
       :keybinding "g")

     (defengine google
       "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

     (defengine rfcs
       "http://pretty-rfc.herokuapp.com/search?q=%s")

     (defengine stack-overflow
       "https://stackoverflow.com/search?q=%s"
       :keybinding "s")

     (defengine wikipedia
       "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
       :keybinding "w")

     (defengine wiktionary
       "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

     (defengine youtube
       "https://www.youtube.com/results?search_query=%s")

     (engine-mode t)
   #+END_SRC

** Multiple cursors

   Having multiple cursors for editing selections is awesome! Agnostic of any
   programming language

   #+begin_src emacs-lisp
     (use-package mark-multiple
       :ensure t
       :bind ("C-c q" . 'mark-next-like-this))
   #+end_src

   #+RESULTS:
   : mark-next-like-this

** Edit as sudo

   #+begin_src emacs-lisp
     (use-package sudo-edit
       :ensure t
       :bind
       ("s-e" . sudo-edit))
   #+end_src

** String casing

   It's super useful to be able to change a string from kebab case
   to camel case, etc.

   #+begin_src emacs-lisp
     (use-package string-inflection
       :ensure t)
   #+end_src

   #+RESULTS:

** CRUX

   This tool is really awesome for all the utility functions it brings

   #+begin_src emacs-lisp
     (use-package crux :ensure t)
   #+end_src

   #+RESULTS:

* Helm

  Man the ship! Helm is a sub community of emacs users who build
  applications ontop of the Helm framework for standard utilities.

  It's extremely handy for autocompleting without tab completion!

  #+BEGIN_SRC emacs-lisp
    (print "Loading helm configs")
                                            ;  :straight (helm :type git :host github :branch "master" :repo "emacs-helm/helm")
    (use-package helm
      :ensure t
      :bind (("M-x" . helm-M-x)
             ("C-x b" . helm-buffers-list)
             ("C-x C-f" . helm-find-files)
             ("C-x r b" . helm-bookmarks)))
  #+END_SRC

  #+RESULTS:
  : helm-bookmarks

** High level helm setup modes and things

   #+BEGIN_SRC emacs-lisp
     (require 'helm-config)
     (helm-mode 1)

     ;; Globally enable fuzzy matching for helm-mode.
     (setq helm-mode-fuzzy-match t)
     (setq helm-completion-in-region-fuzzy-match t)
     (setq helm-M-x-fuzzy-match t)
     (setq helm-buffers-fuzzy-matching t)
     (setq helm-recentf-fuzzy-match t)
     (customize-set-variable 'helm-ff-lynx-style-map t)
     (define-key helm-find-files-map "\t" 'helm-execute-persistent-action)


     ;; Enter directories with RET, same as ido
     ;; http://emacs.stackexchange.com/questions/3798/how-do-i-make-pressing-ret-in-helm-find-files-open-the-directory/7896#7896
     ;(defun helm-find-files-navigate-forward (orig-fun &rest args)
     ;  (if (file-directory-p (helm-get-selection))
     ;      (apply orig-fun args)
     ;    (helm-maybe-exit-minibuffer)))
     ;(advice-add 'helm-execute-persistent-action :around #'helm-find-files-navigate-forward)
     ;(with-eval-after-load 'helm-files
     ;  (define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action))

     ;; major key
     (global-set-key [remap execute-extended-command] #'helm-smex)
   #+END_SRC

   #+RESULTS:
   : helm-smex

** Disable helm in some common emacs apps

   #+BEGIN_SRC emacs-lisp
     ;; Disable Helm in the following functions.
     ;; See: https://github.com/emacs-helm/helm/wiki#customize-helm-mode
     (setq helm-completing-read-handlers-alist
           '((magit-gitignore . nil)
             (rename-file . ido)))
   #+END_SRC

   #+RESULTS:
   : ((magit-gitignore) (rename-file . ido))

** auxilary helm

   This section is mainly for emacs...helm...packages...

   #+BEGIN_SRC emacs-lisp
     ;; Install accompanying helm packages
     (use-package helm-projectile
       :ensure t
       :init
       (setq projectile-completion-system 'helm)
       (helm-projectile-on))
     (use-package helm-tramp
       :ensure t
       :bind ("C-c s" . helm-tramp))
     (setq tramp-default-method "docker")
   #+END_SRC

   #+RESULTS:
   : docker


   Just a few handy functions.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-o") 'other-window)
   #+END_SRC

   #+RESULTS:
   : other-window

   Remap when working in terminal Emacs.

   #+BEGIN_SRC emacs-lisp
     (define-key input-decode-map "\e[1;2A" [S-up])
   #+END_SRC

   #+RESULTS:
   : [S-up]

   I like enlarging and shrinking windows easily

   #+BEGIN_SRC emacs-lisp
     ;; hotkey window resizingx
     (global-set-key (kbd "C-M-<left>") 'shrink-window-horizontally)
     (global-set-key (kbd "C-M-<right>") 'enlarge-window-horizontally)
     (global-set-key (kbd "C-M-<down>") 'shrink-window)
     (global-set-key (kbd "C-M-<up>") 'enlarge-window)
   #+END_SRC

   #+RESULTS:
   : enlarge-window

   Also switching between windows

   #+BEGIN_SRC emacs-lisp
     ;; window switching hotkeys
     (global-set-key (kbd "C-c <left>")  'windmove-left)
     (global-set-key (kbd "C-c <right>") 'windmove-right)
     (global-set-key (kbd "C-c <up>")    'windmove-up)
     (global-set-key (kbd "C-c <down>")  'windmove-down)
   #+END_SRC

   #+RESULTS:
   : windmove-down

   Nice sliding window scrolling

   #+BEGIN_SRC emacs-lisp
     ;; hotkey scrolling
     (defun next-line-and-recenter () (interactive) (next-line) (recenter))
     (defun previous-line-and-recenter () (interactive) (previous-line) (recenter))
     (global-set-key (kbd "C-n") 'next-line-and-recenter)
     (global-set-key (kbd "C-p") 'previous-line-and-recenter)
   #+END_SRC

   #+RESULTS:
   : previous-line-and-recenter

   Run polybar in the background

   #+begin_src emacs-lisp
     (defun kill_polybar ()
       (let ((auto-answer t))
         (when (get-buffer "*trigger_polybar*")
           (kill-buffer "*trigger_polybar*"))))


     (defun trigger_polybar (&optional default-monitor)
       (interactive)
       (unless default-monitor (setq default-monitor ""))
       (kill_polybar)
       (let ((display-buffer-alist
              (cons (cons "\\*trigger_polybar\\*.*"
                          (cons #'display-buffer-no-window nil))
                    display-buffer-alist))) ;; suppress async shell command window
         (async-shell-command
          (concat "trigger_polybar " default-monitor) "*trigger_polybar*")))
   #+end_src

   #+RESULTS:
   : trigger_polybar

* EXWM

  An attempt to switch from i3 to a better X window manager is EXWM.

  In my opinion it is a pretty amazing blend of X and emacs

  #+BEGIN_SRC emacs-lisp
    (print "Loading exwm configs")

    (eval-and-compile
      (straight-use-package 'exwm)
      (require 'exwm-core))

    (use-package exwm
      :straight t
      :config
      (require 'exwm-config)
      (exwm-enable)

      ;; Make a bunch of workspaces
      (setq exwm-workspace-number 4)
      (dotimes (i 4)
        (exwm-input-set-key (kbd (format "s-%d" i))
                            `(lambda ()
                               (interactive)
                               (exwm-workspace-switch-create ,i))))

      ;; config vars
      (setq exwm-manage-codnfigurations '((t line-mode t)))
      (setq exwm-workspace-show-all-buffers t)
      (setq exwm-layout-show-all-buffers t)

      (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
      (define-key exwm-mode-map (kbd "C-c") nil)

      (defun exwm-workspace--current-to-previous-index (_x)
        (setq exwm-workspace-previous-index exwm-workspace-current-index))

      (defun exwm-workspace-previous ()
        (interactive)
        "Switch to the previous workspace."
        (let ((index exwm-workspace-current-index))
          (if (= index 0)
              (exwm-workspace-switch (- exwm-workspace-number 1))
            (exwm-workspace-switch (% (- index 1) exwm-workspace-number)))))

      (defun exwm-workspace-next ()
        (interactive)
        "Switch to the next workspace."
        (let ((index exwm-workspace-current-index))
          (exwm-workspace-switch (% (+ index 1) exwm-workspace-number))))

      (exwm-input-set-key (kbd "s-S-<up>") 'windmove-up)
      (exwm-input-set-key (kbd "s-S-<down>") 'windmove-down)
      (exwm-input-set-key (kbd "s-S-<left>") 'windmove-left)
      (exwm-input-set-key (kbd "s-S-<right>") 'windmove-right)

      (exwm-input-set-key (kbd "C-M-<left>") 'shrink-window-horizontally)
      (exwm-input-set-key (kbd "C-M-<right>") 'enlarge-window-horizontally)
      (exwm-input-set-key (kbd "C-M-<down>") 'shrink-window)
      (exwm-input-set-key (kbd "C-M-<up>") 'enlarge-window)

      (setq exwm-input-global-keys
            `(([?\s-r] . exwm-reset)
              ([?\s-w] . exwm-workspace-switch)
              ([?\s-n] . exwm-workspace-next)
              ([?\s-p] . exwm-workspace-previous)
              ([?\s-&] . (lambda (command)
                           (interactive (list (read-shell-command "$ ")))
                           (start-process-shell-command command nil command)))
              ,@(mapcar (lambda (i)
                          `(,(kbd (format "s-%d" i)) .
                            (lambda ()
                              (interactive)
                              (exwm-workspace-switch-create ,i))))
                        (number-sequence 0 8))))

      (add-hook 'exwm-update-class-hook
                (lambda ()
                  (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                              (string= "gimp" exwm-instance-name))
                    (exwm-workspace-rename-buffer exwm-class-name))))
      (add-hook 'exwm-update-title-hook
                (lambda ()
                  (when (or (not exwm-instance-name)
                            (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                    (exwm-workspace-rename-buffer exwm-title))))


      (setq window-divider-default-right-width 1)
      (window-divider-mode))

    (ignore-errors
      (trigger_polybar))

    (use-package helm-exwm
      :ensure t
      :bind (("s-x" . helm-exwm)))
  #+END_SRC

  #+RESULTS:
  : helm-exwm

  #+begin_src emacs-lisp
    (use-package dmenu
      :ensure t
      :config
      (setq dmenu-prompt-string "dmenu: ")
      (exwm-input-set-key (kbd "s-<return>") 'dmenu))
  #+end_src

  #+RESULTS:
	: t

  #+begin_src emacs-lisp
    (use-package windmove
      :ensure t)
  #+end_src

  #+RESULTS:

  #+begin_src emacs-lisp
    (global-set-key (kbd "<s-up>")     'buf-move-up)
    (global-set-key (kbd "<s-down>")   'buf-move-down)
    (global-set-key (kbd "<s-left>")   'buf-move-left)
    (global-set-key (kbd "<s-right>")  'buf-move-right)
  #+end_src

  #+RESULTS:
	: buf-move-right

  #+begin_src emacs-lisp
    (require 'exwm-randr)
    (exwm-randr-enable)
    (require 'exwm-systemtray)
    (exwm-systemtray-enable)
  #+end_src

  #+RESULTS:
	| exwm-systemtray--exit | exwm-randr--exit |

  #+begin_src emacs-lisp
    (defun my/exwm-randr-auto-get-monitor ()
      (let* ((result)
             (monitors (nth 1 (exwm-randr--get-monitors))))
        (dotimes (i (/ (length monitors) 2))
          (push (nth (* i 2) monitors) result)
          (push i result))
        result))

    (defun monitor-home-setup ()
      (interactive)
      (kill_polybar)
      (setq exwm-randr-workspace-output-plist '(0 "eDP-1" 1 "HDMI-1"))
      ;;(shell-command "xrandr --output HDMI-1 --mode 1920x1080 --above eDP-1 --transform 1.0,0,-48,0,1.0,-20,0,0,1")
      (shell-command "xrandr --output HDMI-1 --mode 1280x720 --right-of eDP-1")
      (trigger_polybar "eDP-1"))

    (defun monitor-home-teardown ()
      (interactive)
      (kill_polybar)
      (setq exwm-randr-workspace-output-plist '(0 "eDP-1"))
      (shell-command "xrandr --output eDP-1 --auto --output HDMI-1 --off")
      (trigger_polybar "eDP-1"))
  #+end_src

  #+RESULTS:
  : monitor-home-teardown


  I really like having a `dashboard` like home screen

  #+begin_src emacs-lisp
    (use-package dashboard
      :ensure t
      :init
      (add-hook 'after-init-hook 'dashboard-refresh-buffer)
      :config
      (setq dashboard-banner-logo-title "Welcome to Amacs!")
      (setq dashboard-image-banner-max-height 200)
      (setq dashboard-image-banner-max-width 200)
      (setq dashboard-center-content t)
      (setq dashboard-startup-banner "~/.emacs.d/resources/penrose.png")
      (dashboard-setup-startup-hook)
      )
  #+end_src

  #+RESULTS:
  : t


* Finish

  Just a simple end log to let me know the config finished

  #+begin_src emacs-lisp
    (message "Finished evaluating config!")
  #+end_src

  #+RESULTS:
	: Finished evaluating config!
